// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loon/messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_loon_2fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_loon_2fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_loon_2fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_loon_2fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_loon_2fmessages_2eproto;
namespace loon {
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class Close;
struct CloseDefaultTypeInternal;
extern CloseDefaultTypeInternal _Close_default_instance_;
class CloseResponse;
struct CloseResponseDefaultTypeInternal;
extern CloseResponseDefaultTypeInternal _CloseResponse_default_instance_;
class Constraints;
struct ConstraintsDefaultTypeInternal;
extern ConstraintsDefaultTypeInternal _Constraints_default_instance_;
class ContentChunk;
struct ContentChunkDefaultTypeInternal;
extern ContentChunkDefaultTypeInternal _ContentChunk_default_instance_;
class ContentHeader;
struct ContentHeaderDefaultTypeInternal;
extern ContentHeaderDefaultTypeInternal _ContentHeader_default_instance_;
class EmptyResponse;
struct EmptyResponseDefaultTypeInternal;
extern EmptyResponseDefaultTypeInternal _EmptyResponse_default_instance_;
class Hello;
struct HelloDefaultTypeInternal;
extern HelloDefaultTypeInternal _Hello_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestClosed;
struct RequestClosedDefaultTypeInternal;
extern RequestClosedDefaultTypeInternal _RequestClosed_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class Success;
struct SuccessDefaultTypeInternal;
extern SuccessDefaultTypeInternal _Success_default_instance_;
}  // namespace loon
PROTOBUF_NAMESPACE_OPEN
template<> ::loon::ClientMessage* Arena::CreateMaybeMessage<::loon::ClientMessage>(Arena*);
template<> ::loon::Close* Arena::CreateMaybeMessage<::loon::Close>(Arena*);
template<> ::loon::CloseResponse* Arena::CreateMaybeMessage<::loon::CloseResponse>(Arena*);
template<> ::loon::Constraints* Arena::CreateMaybeMessage<::loon::Constraints>(Arena*);
template<> ::loon::ContentChunk* Arena::CreateMaybeMessage<::loon::ContentChunk>(Arena*);
template<> ::loon::ContentHeader* Arena::CreateMaybeMessage<::loon::ContentHeader>(Arena*);
template<> ::loon::EmptyResponse* Arena::CreateMaybeMessage<::loon::EmptyResponse>(Arena*);
template<> ::loon::Hello* Arena::CreateMaybeMessage<::loon::Hello>(Arena*);
template<> ::loon::Request* Arena::CreateMaybeMessage<::loon::Request>(Arena*);
template<> ::loon::RequestClosed* Arena::CreateMaybeMessage<::loon::RequestClosed>(Arena*);
template<> ::loon::ServerMessage* Arena::CreateMaybeMessage<::loon::ServerMessage>(Arena*);
template<> ::loon::Success* Arena::CreateMaybeMessage<::loon::Success>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace loon {

enum Close_Reason : int {
  Close_Reason_REASON_UNSPECIFIED = 0,
  Close_Reason_REASON_CLOSED = 1,
  Close_Reason_REASON_ERROR = 2,
  Close_Reason_REASON_INVALID_CLIENT_MESSAGE = 3,
  Close_Reason_REASON_INVALID_REQUEST_ID = 4,
  Close_Reason_REASON_FORBIDDEN_CONTENT_TYPE = 5,
  Close_Reason_REASON_INVALID_CONTENT_SIZE = 6,
  Close_Reason_REASON_CONTENT_CHUNK_OUT_OF_SEQUENCE = 7,
  Close_Reason_REASON_INVALID_CHUNK_SIZE = 8,
  Close_Reason_REASON_INVALID_FILENAME = 9,
  Close_Reason_REASON_TIMED_OUT = 10,
  Close_Reason_Close_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Close_Reason_Close_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Close_Reason_IsValid(int value);
constexpr Close_Reason Close_Reason_Reason_MIN = Close_Reason_REASON_UNSPECIFIED;
constexpr Close_Reason Close_Reason_Reason_MAX = Close_Reason_REASON_TIMED_OUT;
constexpr int Close_Reason_Reason_ARRAYSIZE = Close_Reason_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Close_Reason_descriptor();
template<typename T>
inline const std::string& Close_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Close_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Close_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Close_Reason_descriptor(), enum_t_value);
}
inline bool Close_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Close_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Close_Reason>(
    Close_Reason_descriptor(), name, value);
}
// ===================================================================

class Constraints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.Constraints) */ {
 public:
  inline Constraints() : Constraints(nullptr) {}
  ~Constraints() override;
  explicit PROTOBUF_CONSTEXPR Constraints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Constraints(const Constraints& from);
  Constraints(Constraints&& from) noexcept
    : Constraints() {
    *this = ::std::move(from);
  }

  inline Constraints& operator=(const Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraints& operator=(Constraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraints* internal_default_instance() {
    return reinterpret_cast<const Constraints*>(
               &_Constraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Constraints& a, Constraints& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Constraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Constraints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Constraints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Constraints& from) {
    Constraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.Constraints";
  }
  protected:
  explicit Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedContentTypesFieldNumber = 4,
    kChunkSizeFieldNumber = 1,
    kMaxContentSizeFieldNumber = 2,
  };
  // repeated string accepted_content_types = 4;
  int accepted_content_types_size() const;
  private:
  int _internal_accepted_content_types_size() const;
  public:
  void clear_accepted_content_types();
  const std::string& accepted_content_types(int index) const;
  std::string* mutable_accepted_content_types(int index);
  void set_accepted_content_types(int index, const std::string& value);
  void set_accepted_content_types(int index, std::string&& value);
  void set_accepted_content_types(int index, const char* value);
  void set_accepted_content_types(int index, const char* value, size_t size);
  std::string* add_accepted_content_types();
  void add_accepted_content_types(const std::string& value);
  void add_accepted_content_types(std::string&& value);
  void add_accepted_content_types(const char* value);
  void add_accepted_content_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& accepted_content_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_accepted_content_types();
  private:
  const std::string& _internal_accepted_content_types(int index) const;
  std::string* _internal_add_accepted_content_types();
  public:

  // uint64 chunk_size = 1;
  void clear_chunk_size();
  uint64_t chunk_size() const;
  void set_chunk_size(uint64_t value);
  private:
  uint64_t _internal_chunk_size() const;
  void _internal_set_chunk_size(uint64_t value);
  public:

  // uint64 max_content_size = 2;
  void clear_max_content_size();
  uint64_t max_content_size() const;
  void set_max_content_size(uint64_t value);
  private:
  uint64_t _internal_max_content_size() const;
  void _internal_set_max_content_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.Constraints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> accepted_content_types_;
    uint64_t chunk_size_;
    uint64_t max_content_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Hello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.Hello) */ {
 public:
  inline Hello() : Hello(nullptr) {}
  ~Hello() override;
  explicit PROTOBUF_CONSTEXPR Hello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hello(const Hello& from);
  Hello(Hello&& from) noexcept
    : Hello() {
    *this = ::std::move(from);
  }

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hello& operator=(Hello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hello& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hello* internal_default_instance() {
    return reinterpret_cast<const Hello*>(
               &_Hello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Hello& a, Hello& b) {
    a.Swap(&b);
  }
  inline void Swap(Hello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hello* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hello& from) {
    Hello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.Hello";
  }
  protected:
  explicit Hello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseUrlFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kConnectionSecretFieldNumber = 3,
    kConstraintsFieldNumber = 4,
  };
  // string base_url = 1;
  void clear_base_url();
  const std::string& base_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_url();
  PROTOBUF_NODISCARD std::string* release_base_url();
  void set_allocated_base_url(std::string* base_url);
  private:
  const std::string& _internal_base_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_url(const std::string& value);
  std::string* _internal_mutable_base_url();
  public:

  // string client_id = 2;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // bytes connection_secret = 3;
  void clear_connection_secret();
  const std::string& connection_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_secret();
  PROTOBUF_NODISCARD std::string* release_connection_secret();
  void set_allocated_connection_secret(std::string* connection_secret);
  private:
  const std::string& _internal_connection_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_secret(const std::string& value);
  std::string* _internal_mutable_connection_secret();
  public:

  // .loon.Constraints constraints = 4;
  bool has_constraints() const;
  private:
  bool _internal_has_constraints() const;
  public:
  void clear_constraints();
  const ::loon::Constraints& constraints() const;
  PROTOBUF_NODISCARD ::loon::Constraints* release_constraints();
  ::loon::Constraints* mutable_constraints();
  void set_allocated_constraints(::loon::Constraints* constraints);
  private:
  const ::loon::Constraints& _internal_constraints() const;
  ::loon::Constraints* _internal_mutable_constraints();
  public:
  void unsafe_arena_set_allocated_constraints(
      ::loon::Constraints* constraints);
  ::loon::Constraints* unsafe_arena_release_constraints();

  // @@protoc_insertion_point(class_scope:loon.Hello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_secret_;
    ::loon::Constraints* constraints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class EmptyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.EmptyResponse) */ {
 public:
  inline EmptyResponse() : EmptyResponse(nullptr) {}
  ~EmptyResponse() override;
  explicit PROTOBUF_CONSTEXPR EmptyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyResponse(const EmptyResponse& from);
  EmptyResponse(EmptyResponse&& from) noexcept
    : EmptyResponse() {
    *this = ::std::move(from);
  }

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResponse& operator=(EmptyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResponse* internal_default_instance() {
    return reinterpret_cast<const EmptyResponse*>(
               &_EmptyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EmptyResponse& a, EmptyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyResponse& from) {
    EmptyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.EmptyResponse";
  }
  protected:
  explicit EmptyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.EmptyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ContentHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.ContentHeader) */ {
 public:
  inline ContentHeader() : ContentHeader(nullptr) {}
  ~ContentHeader() override;
  explicit PROTOBUF_CONSTEXPR ContentHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentHeader(const ContentHeader& from);
  ContentHeader(ContentHeader&& from) noexcept
    : ContentHeader() {
    *this = ::std::move(from);
  }

  inline ContentHeader& operator=(const ContentHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentHeader& operator=(ContentHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContentHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentHeader* internal_default_instance() {
    return reinterpret_cast<const ContentHeader*>(
               &_ContentHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContentHeader& a, ContentHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContentHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContentHeader& from) {
    ContentHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContentHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.ContentHeader";
  }
  protected:
  explicit ContentHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentTypeFieldNumber = 2,
    kFilenameFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kContentSizeFieldNumber = 3,
    kMaxCacheDurationFieldNumber = 4,
  };
  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // optional string filename = 5;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // uint64 content_size = 3;
  void clear_content_size();
  uint64_t content_size() const;
  void set_content_size(uint64_t value);
  private:
  uint64_t _internal_content_size() const;
  void _internal_set_content_size(uint64_t value);
  public:

  // optional uint32 max_cache_duration = 4;
  bool has_max_cache_duration() const;
  private:
  bool _internal_has_max_cache_duration() const;
  public:
  void clear_max_cache_duration();
  uint32_t max_cache_duration() const;
  void set_max_cache_duration(uint32_t value);
  private:
  uint32_t _internal_max_cache_duration() const;
  void _internal_set_max_cache_duration(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.ContentHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    uint64_t request_id_;
    uint64_t content_size_;
    uint32_t max_cache_duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ContentChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.ContentChunk) */ {
 public:
  inline ContentChunk() : ContentChunk(nullptr) {}
  ~ContentChunk() override;
  explicit PROTOBUF_CONSTEXPR ContentChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentChunk(const ContentChunk& from);
  ContentChunk(ContentChunk&& from) noexcept
    : ContentChunk() {
    *this = ::std::move(from);
  }

  inline ContentChunk& operator=(const ContentChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentChunk& operator=(ContentChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContentChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentChunk* internal_default_instance() {
    return reinterpret_cast<const ContentChunk*>(
               &_ContentChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ContentChunk& a, ContentChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContentChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContentChunk& from) {
    ContentChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContentChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.ContentChunk";
  }
  protected:
  explicit ContentChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // uint64 sequence = 2;
  void clear_sequence();
  uint64_t sequence() const;
  void set_sequence(uint64_t value);
  private:
  uint64_t _internal_sequence() const;
  void _internal_set_sequence(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.ContentChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t request_id_;
    uint64_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Success final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.Success) */ {
 public:
  inline Success() : Success(nullptr) {}
  ~Success() override;
  explicit PROTOBUF_CONSTEXPR Success(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Success(const Success& from);
  Success(Success&& from) noexcept
    : Success() {
    *this = ::std::move(from);
  }

  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }
  inline Success& operator=(Success&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Success& default_instance() {
    return *internal_default_instance();
  }
  static inline const Success* internal_default_instance() {
    return reinterpret_cast<const Success*>(
               &_Success_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Success& a, Success& b) {
    a.Swap(&b);
  }
  inline void Swap(Success* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Success* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Success* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Success>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Success& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Success& from) {
    Success::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Success* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.Success";
  }
  protected:
  explicit Success(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.Success)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestClosed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.RequestClosed) */ {
 public:
  inline RequestClosed() : RequestClosed(nullptr) {}
  ~RequestClosed() override;
  explicit PROTOBUF_CONSTEXPR RequestClosed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestClosed(const RequestClosed& from);
  RequestClosed(RequestClosed&& from) noexcept
    : RequestClosed() {
    *this = ::std::move(from);
  }

  inline RequestClosed& operator=(const RequestClosed& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestClosed& operator=(RequestClosed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestClosed& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestClosed* internal_default_instance() {
    return reinterpret_cast<const RequestClosed*>(
               &_RequestClosed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestClosed& a, RequestClosed& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestClosed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestClosed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestClosed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestClosed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestClosed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestClosed& from) {
    RequestClosed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestClosed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.RequestClosed";
  }
  protected:
  explicit RequestClosed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.RequestClosed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class CloseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.CloseResponse) */ {
 public:
  inline CloseResponse() : CloseResponse(nullptr) {}
  ~CloseResponse() override;
  explicit PROTOBUF_CONSTEXPR CloseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseResponse(const CloseResponse& from);
  CloseResponse(CloseResponse&& from) noexcept
    : CloseResponse() {
    *this = ::std::move(from);
  }

  inline CloseResponse& operator=(const CloseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseResponse& operator=(CloseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseResponse* internal_default_instance() {
    return reinterpret_cast<const CloseResponse*>(
               &_CloseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CloseResponse& a, CloseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseResponse& from) {
    CloseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.CloseResponse";
  }
  protected:
  explicit CloseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // uint64 request_id = 1;
  void clear_request_id();
  uint64_t request_id() const;
  void set_request_id(uint64_t value);
  private:
  uint64_t _internal_request_id() const;
  void _internal_set_request_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loon.CloseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class Close final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.Close) */ {
 public:
  inline Close() : Close(nullptr) {}
  ~Close() override;
  explicit PROTOBUF_CONSTEXPR Close(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Close(const Close& from);
  Close(Close&& from) noexcept
    : Close() {
    *this = ::std::move(from);
  }

  inline Close& operator=(const Close& from) {
    CopyFrom(from);
    return *this;
  }
  inline Close& operator=(Close&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Close& default_instance() {
    return *internal_default_instance();
  }
  static inline const Close* internal_default_instance() {
    return reinterpret_cast<const Close*>(
               &_Close_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Close& a, Close& b) {
    a.Swap(&b);
  }
  inline void Swap(Close* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Close* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Close* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Close>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Close& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Close& from) {
    Close::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Close* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.Close";
  }
  protected:
  explicit Close(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Close_Reason Reason;
  static constexpr Reason REASON_UNSPECIFIED =
    Close_Reason_REASON_UNSPECIFIED;
  static constexpr Reason REASON_CLOSED =
    Close_Reason_REASON_CLOSED;
  static constexpr Reason REASON_ERROR =
    Close_Reason_REASON_ERROR;
  static constexpr Reason REASON_INVALID_CLIENT_MESSAGE =
    Close_Reason_REASON_INVALID_CLIENT_MESSAGE;
  static constexpr Reason REASON_INVALID_REQUEST_ID =
    Close_Reason_REASON_INVALID_REQUEST_ID;
  static constexpr Reason REASON_FORBIDDEN_CONTENT_TYPE =
    Close_Reason_REASON_FORBIDDEN_CONTENT_TYPE;
  static constexpr Reason REASON_INVALID_CONTENT_SIZE =
    Close_Reason_REASON_INVALID_CONTENT_SIZE;
  static constexpr Reason REASON_CONTENT_CHUNK_OUT_OF_SEQUENCE =
    Close_Reason_REASON_CONTENT_CHUNK_OUT_OF_SEQUENCE;
  static constexpr Reason REASON_INVALID_CHUNK_SIZE =
    Close_Reason_REASON_INVALID_CHUNK_SIZE;
  static constexpr Reason REASON_INVALID_FILENAME =
    Close_Reason_REASON_INVALID_FILENAME;
  static constexpr Reason REASON_TIMED_OUT =
    Close_Reason_REASON_TIMED_OUT;
  static inline bool Reason_IsValid(int value) {
    return Close_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    Close_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    Close_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    Close_Reason_Reason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Reason_descriptor() {
    return Close_Reason_descriptor();
  }
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return Close_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return Close_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kReasonFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .loon.Close.Reason reason = 1;
  void clear_reason();
  ::loon::Close_Reason reason() const;
  void set_reason(::loon::Close_Reason value);
  private:
  ::loon::Close_Reason _internal_reason() const;
  void _internal_set_reason(::loon::Close_Reason value);
  public:

  // @@protoc_insertion_point(class_scope:loon.Close)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ClientMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() override;
  explicit PROTOBUF_CONSTEXPR ClientMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessage(const ClientMessage& from);
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kEmptyResponse = 1,
    kContentHeader = 2,
    kContentChunk = 3,
    kCloseResponse = 4,
    DATA_NOT_SET = 0,
  };

  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientMessage& from) {
    ClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.ClientMessage";
  }
  protected:
  explicit ClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmptyResponseFieldNumber = 1,
    kContentHeaderFieldNumber = 2,
    kContentChunkFieldNumber = 3,
    kCloseResponseFieldNumber = 4,
  };
  // .loon.EmptyResponse empty_response = 1;
  bool has_empty_response() const;
  private:
  bool _internal_has_empty_response() const;
  public:
  void clear_empty_response();
  const ::loon::EmptyResponse& empty_response() const;
  PROTOBUF_NODISCARD ::loon::EmptyResponse* release_empty_response();
  ::loon::EmptyResponse* mutable_empty_response();
  void set_allocated_empty_response(::loon::EmptyResponse* empty_response);
  private:
  const ::loon::EmptyResponse& _internal_empty_response() const;
  ::loon::EmptyResponse* _internal_mutable_empty_response();
  public:
  void unsafe_arena_set_allocated_empty_response(
      ::loon::EmptyResponse* empty_response);
  ::loon::EmptyResponse* unsafe_arena_release_empty_response();

  // .loon.ContentHeader content_header = 2;
  bool has_content_header() const;
  private:
  bool _internal_has_content_header() const;
  public:
  void clear_content_header();
  const ::loon::ContentHeader& content_header() const;
  PROTOBUF_NODISCARD ::loon::ContentHeader* release_content_header();
  ::loon::ContentHeader* mutable_content_header();
  void set_allocated_content_header(::loon::ContentHeader* content_header);
  private:
  const ::loon::ContentHeader& _internal_content_header() const;
  ::loon::ContentHeader* _internal_mutable_content_header();
  public:
  void unsafe_arena_set_allocated_content_header(
      ::loon::ContentHeader* content_header);
  ::loon::ContentHeader* unsafe_arena_release_content_header();

  // .loon.ContentChunk content_chunk = 3;
  bool has_content_chunk() const;
  private:
  bool _internal_has_content_chunk() const;
  public:
  void clear_content_chunk();
  const ::loon::ContentChunk& content_chunk() const;
  PROTOBUF_NODISCARD ::loon::ContentChunk* release_content_chunk();
  ::loon::ContentChunk* mutable_content_chunk();
  void set_allocated_content_chunk(::loon::ContentChunk* content_chunk);
  private:
  const ::loon::ContentChunk& _internal_content_chunk() const;
  ::loon::ContentChunk* _internal_mutable_content_chunk();
  public:
  void unsafe_arena_set_allocated_content_chunk(
      ::loon::ContentChunk* content_chunk);
  ::loon::ContentChunk* unsafe_arena_release_content_chunk();

  // .loon.CloseResponse close_response = 4;
  bool has_close_response() const;
  private:
  bool _internal_has_close_response() const;
  public:
  void clear_close_response();
  const ::loon::CloseResponse& close_response() const;
  PROTOBUF_NODISCARD ::loon::CloseResponse* release_close_response();
  ::loon::CloseResponse* mutable_close_response();
  void set_allocated_close_response(::loon::CloseResponse* close_response);
  private:
  const ::loon::CloseResponse& _internal_close_response() const;
  ::loon::CloseResponse* _internal_mutable_close_response();
  public:
  void unsafe_arena_set_allocated_close_response(
      ::loon::CloseResponse* close_response);
  ::loon::CloseResponse* unsafe_arena_release_close_response();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:loon.ClientMessage)
 private:
  class _Internal;
  void set_has_empty_response();
  void set_has_content_header();
  void set_has_content_chunk();
  void set_has_close_response();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::loon::EmptyResponse* empty_response_;
      ::loon::ContentHeader* content_header_;
      ::loon::ContentChunk* content_chunk_;
      ::loon::CloseResponse* close_response_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loon.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kHello = 1,
    kRequest = 2,
    kSuccess = 3,
    kRequestClosed = 4,
    kClose = 5,
    DATA_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loon.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHelloFieldNumber = 1,
    kRequestFieldNumber = 2,
    kSuccessFieldNumber = 3,
    kRequestClosedFieldNumber = 4,
    kCloseFieldNumber = 5,
  };
  // .loon.Hello hello = 1;
  bool has_hello() const;
  private:
  bool _internal_has_hello() const;
  public:
  void clear_hello();
  const ::loon::Hello& hello() const;
  PROTOBUF_NODISCARD ::loon::Hello* release_hello();
  ::loon::Hello* mutable_hello();
  void set_allocated_hello(::loon::Hello* hello);
  private:
  const ::loon::Hello& _internal_hello() const;
  ::loon::Hello* _internal_mutable_hello();
  public:
  void unsafe_arena_set_allocated_hello(
      ::loon::Hello* hello);
  ::loon::Hello* unsafe_arena_release_hello();

  // .loon.Request request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::loon::Request& request() const;
  PROTOBUF_NODISCARD ::loon::Request* release_request();
  ::loon::Request* mutable_request();
  void set_allocated_request(::loon::Request* request);
  private:
  const ::loon::Request& _internal_request() const;
  ::loon::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::loon::Request* request);
  ::loon::Request* unsafe_arena_release_request();

  // .loon.Success success = 3;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  const ::loon::Success& success() const;
  PROTOBUF_NODISCARD ::loon::Success* release_success();
  ::loon::Success* mutable_success();
  void set_allocated_success(::loon::Success* success);
  private:
  const ::loon::Success& _internal_success() const;
  ::loon::Success* _internal_mutable_success();
  public:
  void unsafe_arena_set_allocated_success(
      ::loon::Success* success);
  ::loon::Success* unsafe_arena_release_success();

  // .loon.RequestClosed request_closed = 4;
  bool has_request_closed() const;
  private:
  bool _internal_has_request_closed() const;
  public:
  void clear_request_closed();
  const ::loon::RequestClosed& request_closed() const;
  PROTOBUF_NODISCARD ::loon::RequestClosed* release_request_closed();
  ::loon::RequestClosed* mutable_request_closed();
  void set_allocated_request_closed(::loon::RequestClosed* request_closed);
  private:
  const ::loon::RequestClosed& _internal_request_closed() const;
  ::loon::RequestClosed* _internal_mutable_request_closed();
  public:
  void unsafe_arena_set_allocated_request_closed(
      ::loon::RequestClosed* request_closed);
  ::loon::RequestClosed* unsafe_arena_release_request_closed();

  // .loon.Close close = 5;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::loon::Close& close() const;
  PROTOBUF_NODISCARD ::loon::Close* release_close();
  ::loon::Close* mutable_close();
  void set_allocated_close(::loon::Close* close);
  private:
  const ::loon::Close& _internal_close() const;
  ::loon::Close* _internal_mutable_close();
  public:
  void unsafe_arena_set_allocated_close(
      ::loon::Close* close);
  ::loon::Close* unsafe_arena_release_close();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:loon.ServerMessage)
 private:
  class _Internal;
  void set_has_hello();
  void set_has_request();
  void set_has_success();
  void set_has_request_closed();
  void set_has_close();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::loon::Hello* hello_;
      ::loon::Request* request_;
      ::loon::Success* success_;
      ::loon::RequestClosed* request_closed_;
      ::loon::Close* close_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loon_2fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Constraints

// uint64 chunk_size = 1;
inline void Constraints::clear_chunk_size() {
  _impl_.chunk_size_ = uint64_t{0u};
}
inline uint64_t Constraints::_internal_chunk_size() const {
  return _impl_.chunk_size_;
}
inline uint64_t Constraints::chunk_size() const {
  // @@protoc_insertion_point(field_get:loon.Constraints.chunk_size)
  return _internal_chunk_size();
}
inline void Constraints::_internal_set_chunk_size(uint64_t value) {
  
  _impl_.chunk_size_ = value;
}
inline void Constraints::set_chunk_size(uint64_t value) {
  _internal_set_chunk_size(value);
  // @@protoc_insertion_point(field_set:loon.Constraints.chunk_size)
}

// uint64 max_content_size = 2;
inline void Constraints::clear_max_content_size() {
  _impl_.max_content_size_ = uint64_t{0u};
}
inline uint64_t Constraints::_internal_max_content_size() const {
  return _impl_.max_content_size_;
}
inline uint64_t Constraints::max_content_size() const {
  // @@protoc_insertion_point(field_get:loon.Constraints.max_content_size)
  return _internal_max_content_size();
}
inline void Constraints::_internal_set_max_content_size(uint64_t value) {
  
  _impl_.max_content_size_ = value;
}
inline void Constraints::set_max_content_size(uint64_t value) {
  _internal_set_max_content_size(value);
  // @@protoc_insertion_point(field_set:loon.Constraints.max_content_size)
}

// repeated string accepted_content_types = 4;
inline int Constraints::_internal_accepted_content_types_size() const {
  return _impl_.accepted_content_types_.size();
}
inline int Constraints::accepted_content_types_size() const {
  return _internal_accepted_content_types_size();
}
inline void Constraints::clear_accepted_content_types() {
  _impl_.accepted_content_types_.Clear();
}
inline std::string* Constraints::add_accepted_content_types() {
  std::string* _s = _internal_add_accepted_content_types();
  // @@protoc_insertion_point(field_add_mutable:loon.Constraints.accepted_content_types)
  return _s;
}
inline const std::string& Constraints::_internal_accepted_content_types(int index) const {
  return _impl_.accepted_content_types_.Get(index);
}
inline const std::string& Constraints::accepted_content_types(int index) const {
  // @@protoc_insertion_point(field_get:loon.Constraints.accepted_content_types)
  return _internal_accepted_content_types(index);
}
inline std::string* Constraints::mutable_accepted_content_types(int index) {
  // @@protoc_insertion_point(field_mutable:loon.Constraints.accepted_content_types)
  return _impl_.accepted_content_types_.Mutable(index);
}
inline void Constraints::set_accepted_content_types(int index, const std::string& value) {
  _impl_.accepted_content_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:loon.Constraints.accepted_content_types)
}
inline void Constraints::set_accepted_content_types(int index, std::string&& value) {
  _impl_.accepted_content_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:loon.Constraints.accepted_content_types)
}
inline void Constraints::set_accepted_content_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.accepted_content_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:loon.Constraints.accepted_content_types)
}
inline void Constraints::set_accepted_content_types(int index, const char* value, size_t size) {
  _impl_.accepted_content_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:loon.Constraints.accepted_content_types)
}
inline std::string* Constraints::_internal_add_accepted_content_types() {
  return _impl_.accepted_content_types_.Add();
}
inline void Constraints::add_accepted_content_types(const std::string& value) {
  _impl_.accepted_content_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:loon.Constraints.accepted_content_types)
}
inline void Constraints::add_accepted_content_types(std::string&& value) {
  _impl_.accepted_content_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:loon.Constraints.accepted_content_types)
}
inline void Constraints::add_accepted_content_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.accepted_content_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:loon.Constraints.accepted_content_types)
}
inline void Constraints::add_accepted_content_types(const char* value, size_t size) {
  _impl_.accepted_content_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:loon.Constraints.accepted_content_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Constraints::accepted_content_types() const {
  // @@protoc_insertion_point(field_list:loon.Constraints.accepted_content_types)
  return _impl_.accepted_content_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Constraints::mutable_accepted_content_types() {
  // @@protoc_insertion_point(field_mutable_list:loon.Constraints.accepted_content_types)
  return &_impl_.accepted_content_types_;
}

// -------------------------------------------------------------------

// Hello

// string base_url = 1;
inline void Hello::clear_base_url() {
  _impl_.base_url_.ClearToEmpty();
}
inline const std::string& Hello::base_url() const {
  // @@protoc_insertion_point(field_get:loon.Hello.base_url)
  return _internal_base_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_base_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.Hello.base_url)
}
inline std::string* Hello::mutable_base_url() {
  std::string* _s = _internal_mutable_base_url();
  // @@protoc_insertion_point(field_mutable:loon.Hello.base_url)
  return _s;
}
inline const std::string& Hello::_internal_base_url() const {
  return _impl_.base_url_.Get();
}
inline void Hello::_internal_set_base_url(const std::string& value) {
  
  _impl_.base_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_base_url() {
  
  return _impl_.base_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_base_url() {
  // @@protoc_insertion_point(field_release:loon.Hello.base_url)
  return _impl_.base_url_.Release();
}
inline void Hello::set_allocated_base_url(std::string* base_url) {
  if (base_url != nullptr) {
    
  } else {
    
  }
  _impl_.base_url_.SetAllocated(base_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_url_.IsDefault()) {
    _impl_.base_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.Hello.base_url)
}

// string client_id = 2;
inline void Hello::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& Hello::client_id() const {
  // @@protoc_insertion_point(field_get:loon.Hello.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.Hello.client_id)
}
inline std::string* Hello::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:loon.Hello.client_id)
  return _s;
}
inline const std::string& Hello::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void Hello::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_client_id() {
  // @@protoc_insertion_point(field_release:loon.Hello.client_id)
  return _impl_.client_id_.Release();
}
inline void Hello::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.Hello.client_id)
}

// bytes connection_secret = 3;
inline void Hello::clear_connection_secret() {
  _impl_.connection_secret_.ClearToEmpty();
}
inline const std::string& Hello::connection_secret() const {
  // @@protoc_insertion_point(field_get:loon.Hello.connection_secret)
  return _internal_connection_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hello::set_connection_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connection_secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.Hello.connection_secret)
}
inline std::string* Hello::mutable_connection_secret() {
  std::string* _s = _internal_mutable_connection_secret();
  // @@protoc_insertion_point(field_mutable:loon.Hello.connection_secret)
  return _s;
}
inline const std::string& Hello::_internal_connection_secret() const {
  return _impl_.connection_secret_.Get();
}
inline void Hello::_internal_set_connection_secret(const std::string& value) {
  
  _impl_.connection_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* Hello::_internal_mutable_connection_secret() {
  
  return _impl_.connection_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* Hello::release_connection_secret() {
  // @@protoc_insertion_point(field_release:loon.Hello.connection_secret)
  return _impl_.connection_secret_.Release();
}
inline void Hello::set_allocated_connection_secret(std::string* connection_secret) {
  if (connection_secret != nullptr) {
    
  } else {
    
  }
  _impl_.connection_secret_.SetAllocated(connection_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_secret_.IsDefault()) {
    _impl_.connection_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.Hello.connection_secret)
}

// .loon.Constraints constraints = 4;
inline bool Hello::_internal_has_constraints() const {
  return this != internal_default_instance() && _impl_.constraints_ != nullptr;
}
inline bool Hello::has_constraints() const {
  return _internal_has_constraints();
}
inline void Hello::clear_constraints() {
  if (GetArenaForAllocation() == nullptr && _impl_.constraints_ != nullptr) {
    delete _impl_.constraints_;
  }
  _impl_.constraints_ = nullptr;
}
inline const ::loon::Constraints& Hello::_internal_constraints() const {
  const ::loon::Constraints* p = _impl_.constraints_;
  return p != nullptr ? *p : reinterpret_cast<const ::loon::Constraints&>(
      ::loon::_Constraints_default_instance_);
}
inline const ::loon::Constraints& Hello::constraints() const {
  // @@protoc_insertion_point(field_get:loon.Hello.constraints)
  return _internal_constraints();
}
inline void Hello::unsafe_arena_set_allocated_constraints(
    ::loon::Constraints* constraints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.constraints_);
  }
  _impl_.constraints_ = constraints;
  if (constraints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.Hello.constraints)
}
inline ::loon::Constraints* Hello::release_constraints() {
  
  ::loon::Constraints* temp = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loon::Constraints* Hello::unsafe_arena_release_constraints() {
  // @@protoc_insertion_point(field_release:loon.Hello.constraints)
  
  ::loon::Constraints* temp = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
  return temp;
}
inline ::loon::Constraints* Hello::_internal_mutable_constraints() {
  
  if (_impl_.constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::loon::Constraints>(GetArenaForAllocation());
    _impl_.constraints_ = p;
  }
  return _impl_.constraints_;
}
inline ::loon::Constraints* Hello::mutable_constraints() {
  ::loon::Constraints* _msg = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:loon.Hello.constraints)
  return _msg;
}
inline void Hello::set_allocated_constraints(::loon::Constraints* constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.constraints_;
  }
  if (constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constraints);
    if (message_arena != submessage_arena) {
      constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:loon.Hello.constraints)
}

// -------------------------------------------------------------------

// Request

// uint64 id = 1;
inline void Request::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Request::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Request::id() const {
  // @@protoc_insertion_point(field_get:loon.Request.id)
  return _internal_id();
}
inline void Request::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Request::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loon.Request.id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool Request::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Request::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Request::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Request::timestamp() const {
  // @@protoc_insertion_point(field_get:loon.Request.timestamp)
  return _internal_timestamp();
}
inline void Request::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.Request.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Request::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Request::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:loon.Request.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Request::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Request::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:loon.Request.timestamp)
  return _msg;
}
inline void Request::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:loon.Request.timestamp)
}

// string path = 3;
inline void Request::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Request::path() const {
  // @@protoc_insertion_point(field_get:loon.Request.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.Request.path)
}
inline std::string* Request::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:loon.Request.path)
  return _s;
}
inline const std::string& Request::_internal_path() const {
  return _impl_.path_.Get();
}
inline void Request::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_path() {
  // @@protoc_insertion_point(field_release:loon.Request.path)
  return _impl_.path_.Release();
}
inline void Request::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.Request.path)
}

// -------------------------------------------------------------------

// EmptyResponse

// uint64 request_id = 1;
inline void EmptyResponse::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t EmptyResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t EmptyResponse::request_id() const {
  // @@protoc_insertion_point(field_get:loon.EmptyResponse.request_id)
  return _internal_request_id();
}
inline void EmptyResponse::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void EmptyResponse::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.EmptyResponse.request_id)
}

// -------------------------------------------------------------------

// ContentHeader

// uint64 request_id = 1;
inline void ContentHeader::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t ContentHeader::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t ContentHeader::request_id() const {
  // @@protoc_insertion_point(field_get:loon.ContentHeader.request_id)
  return _internal_request_id();
}
inline void ContentHeader::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void ContentHeader::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.ContentHeader.request_id)
}

// string content_type = 2;
inline void ContentHeader::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& ContentHeader::content_type() const {
  // @@protoc_insertion_point(field_get:loon.ContentHeader.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentHeader::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.ContentHeader.content_type)
}
inline std::string* ContentHeader::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:loon.ContentHeader.content_type)
  return _s;
}
inline const std::string& ContentHeader::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void ContentHeader::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentHeader::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentHeader::release_content_type() {
  // @@protoc_insertion_point(field_release:loon.ContentHeader.content_type)
  return _impl_.content_type_.Release();
}
inline void ContentHeader::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.ContentHeader.content_type)
}

// uint64 content_size = 3;
inline void ContentHeader::clear_content_size() {
  _impl_.content_size_ = uint64_t{0u};
}
inline uint64_t ContentHeader::_internal_content_size() const {
  return _impl_.content_size_;
}
inline uint64_t ContentHeader::content_size() const {
  // @@protoc_insertion_point(field_get:loon.ContentHeader.content_size)
  return _internal_content_size();
}
inline void ContentHeader::_internal_set_content_size(uint64_t value) {
  
  _impl_.content_size_ = value;
}
inline void ContentHeader::set_content_size(uint64_t value) {
  _internal_set_content_size(value);
  // @@protoc_insertion_point(field_set:loon.ContentHeader.content_size)
}

// optional uint32 max_cache_duration = 4;
inline bool ContentHeader::_internal_has_max_cache_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentHeader::has_max_cache_duration() const {
  return _internal_has_max_cache_duration();
}
inline void ContentHeader::clear_max_cache_duration() {
  _impl_.max_cache_duration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ContentHeader::_internal_max_cache_duration() const {
  return _impl_.max_cache_duration_;
}
inline uint32_t ContentHeader::max_cache_duration() const {
  // @@protoc_insertion_point(field_get:loon.ContentHeader.max_cache_duration)
  return _internal_max_cache_duration();
}
inline void ContentHeader::_internal_set_max_cache_duration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_cache_duration_ = value;
}
inline void ContentHeader::set_max_cache_duration(uint32_t value) {
  _internal_set_max_cache_duration(value);
  // @@protoc_insertion_point(field_set:loon.ContentHeader.max_cache_duration)
}

// optional string filename = 5;
inline bool ContentHeader::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentHeader::has_filename() const {
  return _internal_has_filename();
}
inline void ContentHeader::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentHeader::filename() const {
  // @@protoc_insertion_point(field_get:loon.ContentHeader.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentHeader::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.ContentHeader.filename)
}
inline std::string* ContentHeader::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:loon.ContentHeader.filename)
  return _s;
}
inline const std::string& ContentHeader::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void ContentHeader::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentHeader::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentHeader::release_filename() {
  // @@protoc_insertion_point(field_release:loon.ContentHeader.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentHeader::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.ContentHeader.filename)
}

// -------------------------------------------------------------------

// ContentChunk

// uint64 request_id = 1;
inline void ContentChunk::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t ContentChunk::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t ContentChunk::request_id() const {
  // @@protoc_insertion_point(field_get:loon.ContentChunk.request_id)
  return _internal_request_id();
}
inline void ContentChunk::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void ContentChunk::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.ContentChunk.request_id)
}

// uint64 sequence = 2;
inline void ContentChunk::clear_sequence() {
  _impl_.sequence_ = uint64_t{0u};
}
inline uint64_t ContentChunk::_internal_sequence() const {
  return _impl_.sequence_;
}
inline uint64_t ContentChunk::sequence() const {
  // @@protoc_insertion_point(field_get:loon.ContentChunk.sequence)
  return _internal_sequence();
}
inline void ContentChunk::_internal_set_sequence(uint64_t value) {
  
  _impl_.sequence_ = value;
}
inline void ContentChunk::set_sequence(uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:loon.ContentChunk.sequence)
}

// bytes data = 3;
inline void ContentChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ContentChunk::data() const {
  // @@protoc_insertion_point(field_get:loon.ContentChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.ContentChunk.data)
}
inline std::string* ContentChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:loon.ContentChunk.data)
  return _s;
}
inline const std::string& ContentChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ContentChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentChunk::release_data() {
  // @@protoc_insertion_point(field_release:loon.ContentChunk.data)
  return _impl_.data_.Release();
}
inline void ContentChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.ContentChunk.data)
}

// -------------------------------------------------------------------

// Success

// uint64 request_id = 1;
inline void Success::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t Success::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t Success::request_id() const {
  // @@protoc_insertion_point(field_get:loon.Success.request_id)
  return _internal_request_id();
}
inline void Success::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void Success::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.Success.request_id)
}

// -------------------------------------------------------------------

// RequestClosed

// uint64 request_id = 1;
inline void RequestClosed::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t RequestClosed::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t RequestClosed::request_id() const {
  // @@protoc_insertion_point(field_get:loon.RequestClosed.request_id)
  return _internal_request_id();
}
inline void RequestClosed::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void RequestClosed::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.RequestClosed.request_id)
}

// string message = 2;
inline void RequestClosed::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RequestClosed::message() const {
  // @@protoc_insertion_point(field_get:loon.RequestClosed.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestClosed::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.RequestClosed.message)
}
inline std::string* RequestClosed::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:loon.RequestClosed.message)
  return _s;
}
inline const std::string& RequestClosed::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RequestClosed::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestClosed::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestClosed::release_message() {
  // @@protoc_insertion_point(field_release:loon.RequestClosed.message)
  return _impl_.message_.Release();
}
inline void RequestClosed::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.RequestClosed.message)
}

// -------------------------------------------------------------------

// CloseResponse

// uint64 request_id = 1;
inline void CloseResponse::clear_request_id() {
  _impl_.request_id_ = uint64_t{0u};
}
inline uint64_t CloseResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint64_t CloseResponse::request_id() const {
  // @@protoc_insertion_point(field_get:loon.CloseResponse.request_id)
  return _internal_request_id();
}
inline void CloseResponse::_internal_set_request_id(uint64_t value) {
  
  _impl_.request_id_ = value;
}
inline void CloseResponse::set_request_id(uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:loon.CloseResponse.request_id)
}

// -------------------------------------------------------------------

// Close

// .loon.Close.Reason reason = 1;
inline void Close::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::loon::Close_Reason Close::_internal_reason() const {
  return static_cast< ::loon::Close_Reason >(_impl_.reason_);
}
inline ::loon::Close_Reason Close::reason() const {
  // @@protoc_insertion_point(field_get:loon.Close.reason)
  return _internal_reason();
}
inline void Close::_internal_set_reason(::loon::Close_Reason value) {
  
  _impl_.reason_ = value;
}
inline void Close::set_reason(::loon::Close_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:loon.Close.reason)
}

// string message = 2;
inline void Close::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Close::message() const {
  // @@protoc_insertion_point(field_get:loon.Close.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Close::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:loon.Close.message)
}
inline std::string* Close::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:loon.Close.message)
  return _s;
}
inline const std::string& Close::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Close::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Close::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Close::release_message() {
  // @@protoc_insertion_point(field_release:loon.Close.message)
  return _impl_.message_.Release();
}
inline void Close::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:loon.Close.message)
}

// -------------------------------------------------------------------

// ClientMessage

// .loon.EmptyResponse empty_response = 1;
inline bool ClientMessage::_internal_has_empty_response() const {
  return data_case() == kEmptyResponse;
}
inline bool ClientMessage::has_empty_response() const {
  return _internal_has_empty_response();
}
inline void ClientMessage::set_has_empty_response() {
  _impl_._oneof_case_[0] = kEmptyResponse;
}
inline void ClientMessage::clear_empty_response() {
  if (_internal_has_empty_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.empty_response_;
    }
    clear_has_data();
  }
}
inline ::loon::EmptyResponse* ClientMessage::release_empty_response() {
  // @@protoc_insertion_point(field_release:loon.ClientMessage.empty_response)
  if (_internal_has_empty_response()) {
    clear_has_data();
    ::loon::EmptyResponse* temp = _impl_.data_.empty_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.empty_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::EmptyResponse& ClientMessage::_internal_empty_response() const {
  return _internal_has_empty_response()
      ? *_impl_.data_.empty_response_
      : reinterpret_cast< ::loon::EmptyResponse&>(::loon::_EmptyResponse_default_instance_);
}
inline const ::loon::EmptyResponse& ClientMessage::empty_response() const {
  // @@protoc_insertion_point(field_get:loon.ClientMessage.empty_response)
  return _internal_empty_response();
}
inline ::loon::EmptyResponse* ClientMessage::unsafe_arena_release_empty_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ClientMessage.empty_response)
  if (_internal_has_empty_response()) {
    clear_has_data();
    ::loon::EmptyResponse* temp = _impl_.data_.empty_response_;
    _impl_.data_.empty_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_empty_response(::loon::EmptyResponse* empty_response) {
  clear_data();
  if (empty_response) {
    set_has_empty_response();
    _impl_.data_.empty_response_ = empty_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ClientMessage.empty_response)
}
inline ::loon::EmptyResponse* ClientMessage::_internal_mutable_empty_response() {
  if (!_internal_has_empty_response()) {
    clear_data();
    set_has_empty_response();
    _impl_.data_.empty_response_ = CreateMaybeMessage< ::loon::EmptyResponse >(GetArenaForAllocation());
  }
  return _impl_.data_.empty_response_;
}
inline ::loon::EmptyResponse* ClientMessage::mutable_empty_response() {
  ::loon::EmptyResponse* _msg = _internal_mutable_empty_response();
  // @@protoc_insertion_point(field_mutable:loon.ClientMessage.empty_response)
  return _msg;
}

// .loon.ContentHeader content_header = 2;
inline bool ClientMessage::_internal_has_content_header() const {
  return data_case() == kContentHeader;
}
inline bool ClientMessage::has_content_header() const {
  return _internal_has_content_header();
}
inline void ClientMessage::set_has_content_header() {
  _impl_._oneof_case_[0] = kContentHeader;
}
inline void ClientMessage::clear_content_header() {
  if (_internal_has_content_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.content_header_;
    }
    clear_has_data();
  }
}
inline ::loon::ContentHeader* ClientMessage::release_content_header() {
  // @@protoc_insertion_point(field_release:loon.ClientMessage.content_header)
  if (_internal_has_content_header()) {
    clear_has_data();
    ::loon::ContentHeader* temp = _impl_.data_.content_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.content_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::ContentHeader& ClientMessage::_internal_content_header() const {
  return _internal_has_content_header()
      ? *_impl_.data_.content_header_
      : reinterpret_cast< ::loon::ContentHeader&>(::loon::_ContentHeader_default_instance_);
}
inline const ::loon::ContentHeader& ClientMessage::content_header() const {
  // @@protoc_insertion_point(field_get:loon.ClientMessage.content_header)
  return _internal_content_header();
}
inline ::loon::ContentHeader* ClientMessage::unsafe_arena_release_content_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ClientMessage.content_header)
  if (_internal_has_content_header()) {
    clear_has_data();
    ::loon::ContentHeader* temp = _impl_.data_.content_header_;
    _impl_.data_.content_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_content_header(::loon::ContentHeader* content_header) {
  clear_data();
  if (content_header) {
    set_has_content_header();
    _impl_.data_.content_header_ = content_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ClientMessage.content_header)
}
inline ::loon::ContentHeader* ClientMessage::_internal_mutable_content_header() {
  if (!_internal_has_content_header()) {
    clear_data();
    set_has_content_header();
    _impl_.data_.content_header_ = CreateMaybeMessage< ::loon::ContentHeader >(GetArenaForAllocation());
  }
  return _impl_.data_.content_header_;
}
inline ::loon::ContentHeader* ClientMessage::mutable_content_header() {
  ::loon::ContentHeader* _msg = _internal_mutable_content_header();
  // @@protoc_insertion_point(field_mutable:loon.ClientMessage.content_header)
  return _msg;
}

// .loon.ContentChunk content_chunk = 3;
inline bool ClientMessage::_internal_has_content_chunk() const {
  return data_case() == kContentChunk;
}
inline bool ClientMessage::has_content_chunk() const {
  return _internal_has_content_chunk();
}
inline void ClientMessage::set_has_content_chunk() {
  _impl_._oneof_case_[0] = kContentChunk;
}
inline void ClientMessage::clear_content_chunk() {
  if (_internal_has_content_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.content_chunk_;
    }
    clear_has_data();
  }
}
inline ::loon::ContentChunk* ClientMessage::release_content_chunk() {
  // @@protoc_insertion_point(field_release:loon.ClientMessage.content_chunk)
  if (_internal_has_content_chunk()) {
    clear_has_data();
    ::loon::ContentChunk* temp = _impl_.data_.content_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.content_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::ContentChunk& ClientMessage::_internal_content_chunk() const {
  return _internal_has_content_chunk()
      ? *_impl_.data_.content_chunk_
      : reinterpret_cast< ::loon::ContentChunk&>(::loon::_ContentChunk_default_instance_);
}
inline const ::loon::ContentChunk& ClientMessage::content_chunk() const {
  // @@protoc_insertion_point(field_get:loon.ClientMessage.content_chunk)
  return _internal_content_chunk();
}
inline ::loon::ContentChunk* ClientMessage::unsafe_arena_release_content_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ClientMessage.content_chunk)
  if (_internal_has_content_chunk()) {
    clear_has_data();
    ::loon::ContentChunk* temp = _impl_.data_.content_chunk_;
    _impl_.data_.content_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_content_chunk(::loon::ContentChunk* content_chunk) {
  clear_data();
  if (content_chunk) {
    set_has_content_chunk();
    _impl_.data_.content_chunk_ = content_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ClientMessage.content_chunk)
}
inline ::loon::ContentChunk* ClientMessage::_internal_mutable_content_chunk() {
  if (!_internal_has_content_chunk()) {
    clear_data();
    set_has_content_chunk();
    _impl_.data_.content_chunk_ = CreateMaybeMessage< ::loon::ContentChunk >(GetArenaForAllocation());
  }
  return _impl_.data_.content_chunk_;
}
inline ::loon::ContentChunk* ClientMessage::mutable_content_chunk() {
  ::loon::ContentChunk* _msg = _internal_mutable_content_chunk();
  // @@protoc_insertion_point(field_mutable:loon.ClientMessage.content_chunk)
  return _msg;
}

// .loon.CloseResponse close_response = 4;
inline bool ClientMessage::_internal_has_close_response() const {
  return data_case() == kCloseResponse;
}
inline bool ClientMessage::has_close_response() const {
  return _internal_has_close_response();
}
inline void ClientMessage::set_has_close_response() {
  _impl_._oneof_case_[0] = kCloseResponse;
}
inline void ClientMessage::clear_close_response() {
  if (_internal_has_close_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.close_response_;
    }
    clear_has_data();
  }
}
inline ::loon::CloseResponse* ClientMessage::release_close_response() {
  // @@protoc_insertion_point(field_release:loon.ClientMessage.close_response)
  if (_internal_has_close_response()) {
    clear_has_data();
    ::loon::CloseResponse* temp = _impl_.data_.close_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.close_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::CloseResponse& ClientMessage::_internal_close_response() const {
  return _internal_has_close_response()
      ? *_impl_.data_.close_response_
      : reinterpret_cast< ::loon::CloseResponse&>(::loon::_CloseResponse_default_instance_);
}
inline const ::loon::CloseResponse& ClientMessage::close_response() const {
  // @@protoc_insertion_point(field_get:loon.ClientMessage.close_response)
  return _internal_close_response();
}
inline ::loon::CloseResponse* ClientMessage::unsafe_arena_release_close_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ClientMessage.close_response)
  if (_internal_has_close_response()) {
    clear_has_data();
    ::loon::CloseResponse* temp = _impl_.data_.close_response_;
    _impl_.data_.close_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_close_response(::loon::CloseResponse* close_response) {
  clear_data();
  if (close_response) {
    set_has_close_response();
    _impl_.data_.close_response_ = close_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ClientMessage.close_response)
}
inline ::loon::CloseResponse* ClientMessage::_internal_mutable_close_response() {
  if (!_internal_has_close_response()) {
    clear_data();
    set_has_close_response();
    _impl_.data_.close_response_ = CreateMaybeMessage< ::loon::CloseResponse >(GetArenaForAllocation());
  }
  return _impl_.data_.close_response_;
}
inline ::loon::CloseResponse* ClientMessage::mutable_close_response() {
  ::loon::CloseResponse* _msg = _internal_mutable_close_response();
  // @@protoc_insertion_point(field_mutable:loon.ClientMessage.close_response)
  return _msg;
}

inline bool ClientMessage::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ClientMessage::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline ClientMessage::DataCase ClientMessage::data_case() const {
  return ClientMessage::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .loon.Hello hello = 1;
inline bool ServerMessage::_internal_has_hello() const {
  return data_case() == kHello;
}
inline bool ServerMessage::has_hello() const {
  return _internal_has_hello();
}
inline void ServerMessage::set_has_hello() {
  _impl_._oneof_case_[0] = kHello;
}
inline void ServerMessage::clear_hello() {
  if (_internal_has_hello()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.hello_;
    }
    clear_has_data();
  }
}
inline ::loon::Hello* ServerMessage::release_hello() {
  // @@protoc_insertion_point(field_release:loon.ServerMessage.hello)
  if (_internal_has_hello()) {
    clear_has_data();
    ::loon::Hello* temp = _impl_.data_.hello_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::Hello& ServerMessage::_internal_hello() const {
  return _internal_has_hello()
      ? *_impl_.data_.hello_
      : reinterpret_cast< ::loon::Hello&>(::loon::_Hello_default_instance_);
}
inline const ::loon::Hello& ServerMessage::hello() const {
  // @@protoc_insertion_point(field_get:loon.ServerMessage.hello)
  return _internal_hello();
}
inline ::loon::Hello* ServerMessage::unsafe_arena_release_hello() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ServerMessage.hello)
  if (_internal_has_hello()) {
    clear_has_data();
    ::loon::Hello* temp = _impl_.data_.hello_;
    _impl_.data_.hello_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_hello(::loon::Hello* hello) {
  clear_data();
  if (hello) {
    set_has_hello();
    _impl_.data_.hello_ = hello;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ServerMessage.hello)
}
inline ::loon::Hello* ServerMessage::_internal_mutable_hello() {
  if (!_internal_has_hello()) {
    clear_data();
    set_has_hello();
    _impl_.data_.hello_ = CreateMaybeMessage< ::loon::Hello >(GetArenaForAllocation());
  }
  return _impl_.data_.hello_;
}
inline ::loon::Hello* ServerMessage::mutable_hello() {
  ::loon::Hello* _msg = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:loon.ServerMessage.hello)
  return _msg;
}

// .loon.Request request = 2;
inline bool ServerMessage::_internal_has_request() const {
  return data_case() == kRequest;
}
inline bool ServerMessage::has_request() const {
  return _internal_has_request();
}
inline void ServerMessage::set_has_request() {
  _impl_._oneof_case_[0] = kRequest;
}
inline void ServerMessage::clear_request() {
  if (_internal_has_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.request_;
    }
    clear_has_data();
  }
}
inline ::loon::Request* ServerMessage::release_request() {
  // @@protoc_insertion_point(field_release:loon.ServerMessage.request)
  if (_internal_has_request()) {
    clear_has_data();
    ::loon::Request* temp = _impl_.data_.request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::Request& ServerMessage::_internal_request() const {
  return _internal_has_request()
      ? *_impl_.data_.request_
      : reinterpret_cast< ::loon::Request&>(::loon::_Request_default_instance_);
}
inline const ::loon::Request& ServerMessage::request() const {
  // @@protoc_insertion_point(field_get:loon.ServerMessage.request)
  return _internal_request();
}
inline ::loon::Request* ServerMessage::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ServerMessage.request)
  if (_internal_has_request()) {
    clear_has_data();
    ::loon::Request* temp = _impl_.data_.request_;
    _impl_.data_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_request(::loon::Request* request) {
  clear_data();
  if (request) {
    set_has_request();
    _impl_.data_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ServerMessage.request)
}
inline ::loon::Request* ServerMessage::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_data();
    set_has_request();
    _impl_.data_.request_ = CreateMaybeMessage< ::loon::Request >(GetArenaForAllocation());
  }
  return _impl_.data_.request_;
}
inline ::loon::Request* ServerMessage::mutable_request() {
  ::loon::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:loon.ServerMessage.request)
  return _msg;
}

// .loon.Success success = 3;
inline bool ServerMessage::_internal_has_success() const {
  return data_case() == kSuccess;
}
inline bool ServerMessage::has_success() const {
  return _internal_has_success();
}
inline void ServerMessage::set_has_success() {
  _impl_._oneof_case_[0] = kSuccess;
}
inline void ServerMessage::clear_success() {
  if (_internal_has_success()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.success_;
    }
    clear_has_data();
  }
}
inline ::loon::Success* ServerMessage::release_success() {
  // @@protoc_insertion_point(field_release:loon.ServerMessage.success)
  if (_internal_has_success()) {
    clear_has_data();
    ::loon::Success* temp = _impl_.data_.success_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.success_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::Success& ServerMessage::_internal_success() const {
  return _internal_has_success()
      ? *_impl_.data_.success_
      : reinterpret_cast< ::loon::Success&>(::loon::_Success_default_instance_);
}
inline const ::loon::Success& ServerMessage::success() const {
  // @@protoc_insertion_point(field_get:loon.ServerMessage.success)
  return _internal_success();
}
inline ::loon::Success* ServerMessage::unsafe_arena_release_success() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ServerMessage.success)
  if (_internal_has_success()) {
    clear_has_data();
    ::loon::Success* temp = _impl_.data_.success_;
    _impl_.data_.success_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_success(::loon::Success* success) {
  clear_data();
  if (success) {
    set_has_success();
    _impl_.data_.success_ = success;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ServerMessage.success)
}
inline ::loon::Success* ServerMessage::_internal_mutable_success() {
  if (!_internal_has_success()) {
    clear_data();
    set_has_success();
    _impl_.data_.success_ = CreateMaybeMessage< ::loon::Success >(GetArenaForAllocation());
  }
  return _impl_.data_.success_;
}
inline ::loon::Success* ServerMessage::mutable_success() {
  ::loon::Success* _msg = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:loon.ServerMessage.success)
  return _msg;
}

// .loon.RequestClosed request_closed = 4;
inline bool ServerMessage::_internal_has_request_closed() const {
  return data_case() == kRequestClosed;
}
inline bool ServerMessage::has_request_closed() const {
  return _internal_has_request_closed();
}
inline void ServerMessage::set_has_request_closed() {
  _impl_._oneof_case_[0] = kRequestClosed;
}
inline void ServerMessage::clear_request_closed() {
  if (_internal_has_request_closed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.request_closed_;
    }
    clear_has_data();
  }
}
inline ::loon::RequestClosed* ServerMessage::release_request_closed() {
  // @@protoc_insertion_point(field_release:loon.ServerMessage.request_closed)
  if (_internal_has_request_closed()) {
    clear_has_data();
    ::loon::RequestClosed* temp = _impl_.data_.request_closed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.request_closed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::RequestClosed& ServerMessage::_internal_request_closed() const {
  return _internal_has_request_closed()
      ? *_impl_.data_.request_closed_
      : reinterpret_cast< ::loon::RequestClosed&>(::loon::_RequestClosed_default_instance_);
}
inline const ::loon::RequestClosed& ServerMessage::request_closed() const {
  // @@protoc_insertion_point(field_get:loon.ServerMessage.request_closed)
  return _internal_request_closed();
}
inline ::loon::RequestClosed* ServerMessage::unsafe_arena_release_request_closed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ServerMessage.request_closed)
  if (_internal_has_request_closed()) {
    clear_has_data();
    ::loon::RequestClosed* temp = _impl_.data_.request_closed_;
    _impl_.data_.request_closed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_request_closed(::loon::RequestClosed* request_closed) {
  clear_data();
  if (request_closed) {
    set_has_request_closed();
    _impl_.data_.request_closed_ = request_closed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ServerMessage.request_closed)
}
inline ::loon::RequestClosed* ServerMessage::_internal_mutable_request_closed() {
  if (!_internal_has_request_closed()) {
    clear_data();
    set_has_request_closed();
    _impl_.data_.request_closed_ = CreateMaybeMessage< ::loon::RequestClosed >(GetArenaForAllocation());
  }
  return _impl_.data_.request_closed_;
}
inline ::loon::RequestClosed* ServerMessage::mutable_request_closed() {
  ::loon::RequestClosed* _msg = _internal_mutable_request_closed();
  // @@protoc_insertion_point(field_mutable:loon.ServerMessage.request_closed)
  return _msg;
}

// .loon.Close close = 5;
inline bool ServerMessage::_internal_has_close() const {
  return data_case() == kClose;
}
inline bool ServerMessage::has_close() const {
  return _internal_has_close();
}
inline void ServerMessage::set_has_close() {
  _impl_._oneof_case_[0] = kClose;
}
inline void ServerMessage::clear_close() {
  if (_internal_has_close()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.close_;
    }
    clear_has_data();
  }
}
inline ::loon::Close* ServerMessage::release_close() {
  // @@protoc_insertion_point(field_release:loon.ServerMessage.close)
  if (_internal_has_close()) {
    clear_has_data();
    ::loon::Close* temp = _impl_.data_.close_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::loon::Close& ServerMessage::_internal_close() const {
  return _internal_has_close()
      ? *_impl_.data_.close_
      : reinterpret_cast< ::loon::Close&>(::loon::_Close_default_instance_);
}
inline const ::loon::Close& ServerMessage::close() const {
  // @@protoc_insertion_point(field_get:loon.ServerMessage.close)
  return _internal_close();
}
inline ::loon::Close* ServerMessage::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:loon.ServerMessage.close)
  if (_internal_has_close()) {
    clear_has_data();
    ::loon::Close* temp = _impl_.data_.close_;
    _impl_.data_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_close(::loon::Close* close) {
  clear_data();
  if (close) {
    set_has_close();
    _impl_.data_.close_ = close;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loon.ServerMessage.close)
}
inline ::loon::Close* ServerMessage::_internal_mutable_close() {
  if (!_internal_has_close()) {
    clear_data();
    set_has_close();
    _impl_.data_.close_ = CreateMaybeMessage< ::loon::Close >(GetArenaForAllocation());
  }
  return _impl_.data_.close_;
}
inline ::loon::Close* ServerMessage::mutable_close() {
  ::loon::Close* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:loon.ServerMessage.close)
  return _msg;
}

inline bool ServerMessage::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ServerMessage::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline ServerMessage::DataCase ServerMessage::data_case() const {
  return ServerMessage::DataCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace loon

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::loon::Close_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::loon::Close_Reason>() {
  return ::loon::Close_Reason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_loon_2fmessages_2eproto
