// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loon/messages.proto

#include "loon/messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace loon {
PROTOBUF_CONSTEXPR Constraints::Constraints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accepted_content_types_)*/{}
  , /*decltype(_impl_.chunk_size_)*/uint64_t{0u}
  , /*decltype(_impl_.max_content_size_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstraintsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstraintsDefaultTypeInternal() {}
  union {
    Constraints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstraintsDefaultTypeInternal _Constraints_default_instance_;
PROTOBUF_CONSTEXPR Hello::Hello(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_secret_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.constraints_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HelloDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HelloDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HelloDefaultTypeInternal() {}
  union {
    Hello _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HelloDefaultTypeInternal _Hello_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR EmptyResponse::EmptyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmptyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyResponseDefaultTypeInternal() {}
  union {
    EmptyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyResponseDefaultTypeInternal _EmptyResponse_default_instance_;
PROTOBUF_CONSTEXPR ContentHeader::ContentHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.content_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_.content_size_)*/uint64_t{0u}
  , /*decltype(_impl_.max_cache_duration_)*/0u} {}
struct ContentHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentHeaderDefaultTypeInternal() {}
  union {
    ContentHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentHeaderDefaultTypeInternal _ContentHeader_default_instance_;
PROTOBUF_CONSTEXPR ContentChunk::ContentChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_.sequence_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContentChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentChunkDefaultTypeInternal() {}
  union {
    ContentChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentChunkDefaultTypeInternal _ContentChunk_default_instance_;
PROTOBUF_CONSTEXPR Success::Success(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SuccessDefaultTypeInternal() {}
  union {
    Success _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SuccessDefaultTypeInternal _Success_default_instance_;
PROTOBUF_CONSTEXPR RequestClosed::RequestClosed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestClosedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestClosedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestClosedDefaultTypeInternal() {}
  union {
    RequestClosed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestClosedDefaultTypeInternal _RequestClosed_default_instance_;
PROTOBUF_CONSTEXPR CloseResponse::CloseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CloseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseResponseDefaultTypeInternal() {}
  union {
    CloseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseResponseDefaultTypeInternal _CloseResponse_default_instance_;
PROTOBUF_CONSTEXPR Close::Close(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CloseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CloseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CloseDefaultTypeInternal() {}
  union {
    Close _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloseDefaultTypeInternal _Close_default_instance_;
PROTOBUF_CONSTEXPR ClientMessage::ClientMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ClientMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMessageDefaultTypeInternal() {}
  union {
    ClientMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
PROTOBUF_CONSTEXPR ServerMessage::ServerMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ServerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerMessageDefaultTypeInternal() {}
  union {
    ServerMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace loon
static ::_pb::Metadata file_level_metadata_loon_2fmessages_2eproto[12];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_loon_2fmessages_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_loon_2fmessages_2eproto = nullptr;

const uint32_t TableStruct_loon_2fmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::Constraints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::Constraints, _impl_.chunk_size_),
  PROTOBUF_FIELD_OFFSET(::loon::Constraints, _impl_.max_content_size_),
  PROTOBUF_FIELD_OFFSET(::loon::Constraints, _impl_.accepted_content_types_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::Hello, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::Hello, _impl_.base_url_),
  PROTOBUF_FIELD_OFFSET(::loon::Hello, _impl_.client_id_),
  PROTOBUF_FIELD_OFFSET(::loon::Hello, _impl_.connection_secret_),
  PROTOBUF_FIELD_OFFSET(::loon::Hello, _impl_.constraints_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::Request, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::loon::Request, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::loon::Request, _impl_.path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::EmptyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::EmptyResponse, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_.content_type_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_.content_size_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_.max_cache_duration_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentHeader, _impl_.filename_),
  ~0u,
  ~0u,
  ~0u,
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::ContentChunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::ContentChunk, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentChunk, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::loon::ContentChunk, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::Success, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::Success, _impl_.request_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::RequestClosed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::RequestClosed, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::loon::RequestClosed, _impl_.message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::CloseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::CloseResponse, _impl_.request_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::Close, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loon::Close, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::loon::Close, _impl_.message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::ClientMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::loon::ClientMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::loon::ClientMessage, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::loon::ServerMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::loon::ServerMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::loon::ServerMessage, _impl_.data_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::loon::Constraints)},
  { 9, -1, -1, sizeof(::loon::Hello)},
  { 19, -1, -1, sizeof(::loon::Request)},
  { 28, -1, -1, sizeof(::loon::EmptyResponse)},
  { 35, 46, -1, sizeof(::loon::ContentHeader)},
  { 51, -1, -1, sizeof(::loon::ContentChunk)},
  { 60, -1, -1, sizeof(::loon::Success)},
  { 67, -1, -1, sizeof(::loon::RequestClosed)},
  { 75, -1, -1, sizeof(::loon::CloseResponse)},
  { 82, -1, -1, sizeof(::loon::Close)},
  { 90, -1, -1, sizeof(::loon::ClientMessage)},
  { 101, -1, -1, sizeof(::loon::ServerMessage)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::loon::_Constraints_default_instance_._instance,
  &::loon::_Hello_default_instance_._instance,
  &::loon::_Request_default_instance_._instance,
  &::loon::_EmptyResponse_default_instance_._instance,
  &::loon::_ContentHeader_default_instance_._instance,
  &::loon::_ContentChunk_default_instance_._instance,
  &::loon::_Success_default_instance_._instance,
  &::loon::_RequestClosed_default_instance_._instance,
  &::loon::_CloseResponse_default_instance_._instance,
  &::loon::_Close_default_instance_._instance,
  &::loon::_ClientMessage_default_instance_._instance,
  &::loon::_ServerMessage_default_instance_._instance,
};

const char descriptor_table_protodef_loon_2fmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023loon/messages.proto\022\004loon\032\037google/prot"
  "obuf/timestamp.proto\"[\n\013Constraints\022\022\n\nc"
  "hunk_size\030\001 \001(\004\022\030\n\020max_content_size\030\002 \001("
  "\004\022\036\n\026accepted_content_types\030\004 \003(\t\"o\n\005Hel"
  "lo\022\020\n\010base_url\030\001 \001(\t\022\021\n\tclient_id\030\002 \001(\t\022"
  "\031\n\021connection_secret\030\003 \001(\014\022&\n\013constraint"
  "s\030\004 \001(\0132\021.loon.Constraints\"R\n\007Request\022\n\n"
  "\002id\030\001 \001(\004\022-\n\ttimestamp\030\002 \001(\0132\032.google.pr"
  "otobuf.Timestamp\022\014\n\004path\030\003 \001(\t\"#\n\rEmptyR"
  "esponse\022\022\n\nrequest_id\030\001 \001(\004\"\253\001\n\rContentH"
  "eader\022\022\n\nrequest_id\030\001 \001(\004\022\024\n\014content_typ"
  "e\030\002 \001(\t\022\024\n\014content_size\030\003 \001(\004\022\037\n\022max_cac"
  "he_duration\030\004 \001(\rH\000\210\001\001\022\025\n\010filename\030\005 \001(\t"
  "H\001\210\001\001B\025\n\023_max_cache_durationB\013\n\t_filenam"
  "e\"B\n\014ContentChunk\022\022\n\nrequest_id\030\001 \001(\004\022\020\n"
  "\010sequence\030\002 \001(\004\022\014\n\004data\030\003 \001(\014\"\035\n\007Success"
  "\022\022\n\nrequest_id\030\001 \001(\004\"4\n\rRequestClosed\022\022\n"
  "\nrequest_id\030\001 \001(\004\022\017\n\007message\030\002 \001(\t\"#\n\rCl"
  "oseResponse\022\022\n\nrequest_id\030\001 \001(\004\"\206\003\n\005Clos"
  "e\022\"\n\006reason\030\001 \001(\0162\022.loon.Close.Reason\022\017\n"
  "\007message\030\002 \001(\t\"\307\002\n\006Reason\022\026\n\022REASON_UNSP"
  "ECIFIED\020\000\022\021\n\rREASON_CLOSED\020\001\022\020\n\014REASON_E"
  "RROR\020\002\022!\n\035REASON_INVALID_CLIENT_MESSAGE\020"
  "\003\022\035\n\031REASON_INVALID_REQUEST_ID\020\004\022!\n\035REAS"
  "ON_FORBIDDEN_CONTENT_TYPE\020\005\022\037\n\033REASON_IN"
  "VALID_CONTENT_SIZE\020\006\022(\n$REASON_CONTENT_C"
  "HUNK_OUT_OF_SEQUENCE\020\007\022\035\n\031REASON_INVALID"
  "_CHUNK_SIZE\020\010\022\033\n\027REASON_INVALID_FILENAME"
  "\020\t\022\024\n\020REASON_TIMED_OUT\020\n\"\321\001\n\rClientMessa"
  "ge\022-\n\016empty_response\030\001 \001(\0132\023.loon.EmptyR"
  "esponseH\000\022-\n\016content_header\030\002 \001(\0132\023.loon"
  ".ContentHeaderH\000\022+\n\rcontent_chunk\030\003 \001(\0132"
  "\022.loon.ContentChunkH\000\022-\n\016close_response\030"
  "\004 \001(\0132\023.loon.CloseResponseH\000B\006\n\004data\"\306\001\n"
  "\rServerMessage\022\034\n\005hello\030\001 \001(\0132\013.loon.Hel"
  "loH\000\022 \n\007request\030\002 \001(\0132\r.loon.RequestH\000\022 "
  "\n\007success\030\003 \001(\0132\r.loon.SuccessH\000\022-\n\016requ"
  "est_closed\030\004 \001(\0132\023.loon.RequestClosedH\000\022"
  "\034\n\005close\030\005 \001(\0132\013.loon.CloseH\000B\006\n\004dataB\005Z"
  "\003/pbb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_loon_2fmessages_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::_pbi::once_flag descriptor_table_loon_2fmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_loon_2fmessages_2eproto = {
    false, false, 1572, descriptor_table_protodef_loon_2fmessages_2eproto,
    "loon/messages.proto",
    &descriptor_table_loon_2fmessages_2eproto_once, descriptor_table_loon_2fmessages_2eproto_deps, 1, 12,
    schemas, file_default_instances, TableStruct_loon_2fmessages_2eproto::offsets,
    file_level_metadata_loon_2fmessages_2eproto, file_level_enum_descriptors_loon_2fmessages_2eproto,
    file_level_service_descriptors_loon_2fmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_loon_2fmessages_2eproto_getter() {
  return &descriptor_table_loon_2fmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_loon_2fmessages_2eproto(&descriptor_table_loon_2fmessages_2eproto);
namespace loon {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Close_Reason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_loon_2fmessages_2eproto);
  return file_level_enum_descriptors_loon_2fmessages_2eproto[0];
}
bool Close_Reason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Close_Reason Close::REASON_UNSPECIFIED;
constexpr Close_Reason Close::REASON_CLOSED;
constexpr Close_Reason Close::REASON_ERROR;
constexpr Close_Reason Close::REASON_INVALID_CLIENT_MESSAGE;
constexpr Close_Reason Close::REASON_INVALID_REQUEST_ID;
constexpr Close_Reason Close::REASON_FORBIDDEN_CONTENT_TYPE;
constexpr Close_Reason Close::REASON_INVALID_CONTENT_SIZE;
constexpr Close_Reason Close::REASON_CONTENT_CHUNK_OUT_OF_SEQUENCE;
constexpr Close_Reason Close::REASON_INVALID_CHUNK_SIZE;
constexpr Close_Reason Close::REASON_INVALID_FILENAME;
constexpr Close_Reason Close::REASON_TIMED_OUT;
constexpr Close_Reason Close::Reason_MIN;
constexpr Close_Reason Close::Reason_MAX;
constexpr int Close::Reason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Constraints::_Internal {
 public:
};

Constraints::Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.Constraints)
}
Constraints::Constraints(const Constraints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Constraints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accepted_content_types_){from._impl_.accepted_content_types_}
    , decltype(_impl_.chunk_size_){}
    , decltype(_impl_.max_content_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.chunk_size_, &from._impl_.chunk_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_content_size_) -
    reinterpret_cast<char*>(&_impl_.chunk_size_)) + sizeof(_impl_.max_content_size_));
  // @@protoc_insertion_point(copy_constructor:loon.Constraints)
}

inline void Constraints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accepted_content_types_){arena}
    , decltype(_impl_.chunk_size_){uint64_t{0u}}
    , decltype(_impl_.max_content_size_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Constraints::~Constraints() {
  // @@protoc_insertion_point(destructor:loon.Constraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Constraints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accepted_content_types_.~RepeatedPtrField();
}

void Constraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Constraints::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.Constraints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accepted_content_types_.Clear();
  ::memset(&_impl_.chunk_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_content_size_) -
      reinterpret_cast<char*>(&_impl_.chunk_size_)) + sizeof(_impl_.max_content_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Constraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 chunk_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 max_content_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.max_content_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string accepted_content_types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_accepted_content_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "loon.Constraints.accepted_content_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Constraints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.Constraints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 chunk_size = 1;
  if (this->_internal_chunk_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_chunk_size(), target);
  }

  // uint64 max_content_size = 2;
  if (this->_internal_max_content_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_content_size(), target);
  }

  // repeated string accepted_content_types = 4;
  for (int i = 0, n = this->_internal_accepted_content_types_size(); i < n; i++) {
    const auto& s = this->_internal_accepted_content_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.Constraints.accepted_content_types");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.Constraints)
  return target;
}

size_t Constraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.Constraints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string accepted_content_types = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.accepted_content_types_.size());
  for (int i = 0, n = _impl_.accepted_content_types_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.accepted_content_types_.Get(i));
  }

  // uint64 chunk_size = 1;
  if (this->_internal_chunk_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_chunk_size());
  }

  // uint64 max_content_size = 2;
  if (this->_internal_max_content_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_content_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Constraints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Constraints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Constraints::GetClassData() const { return &_class_data_; }


void Constraints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Constraints*>(&to_msg);
  auto& from = static_cast<const Constraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.Constraints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accepted_content_types_.MergeFrom(from._impl_.accepted_content_types_);
  if (from._internal_chunk_size() != 0) {
    _this->_internal_set_chunk_size(from._internal_chunk_size());
  }
  if (from._internal_max_content_size() != 0) {
    _this->_internal_set_max_content_size(from._internal_max_content_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Constraints::CopyFrom(const Constraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.Constraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Constraints::IsInitialized() const {
  return true;
}

void Constraints::InternalSwap(Constraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.accepted_content_types_.InternalSwap(&other->_impl_.accepted_content_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Constraints, _impl_.max_content_size_)
      + sizeof(Constraints::_impl_.max_content_size_)
      - PROTOBUF_FIELD_OFFSET(Constraints, _impl_.chunk_size_)>(
          reinterpret_cast<char*>(&_impl_.chunk_size_),
          reinterpret_cast<char*>(&other->_impl_.chunk_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Constraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[0]);
}

// ===================================================================

class Hello::_Internal {
 public:
  static const ::loon::Constraints& constraints(const Hello* msg);
};

const ::loon::Constraints&
Hello::_Internal::constraints(const Hello* msg) {
  return *msg->_impl_.constraints_;
}
Hello::Hello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.Hello)
}
Hello::Hello(const Hello& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Hello* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_url_){}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.connection_secret_){}
    , decltype(_impl_.constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.base_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_url().empty()) {
    _this->_impl_.base_url_.Set(from._internal_base_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client_id().empty()) {
    _this->_impl_.client_id_.Set(from._internal_client_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.connection_secret_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.connection_secret_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_connection_secret().empty()) {
    _this->_impl_.connection_secret_.Set(from._internal_connection_secret(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_constraints()) {
    _this->_impl_.constraints_ = new ::loon::Constraints(*from._impl_.constraints_);
  }
  // @@protoc_insertion_point(copy_constructor:loon.Hello)
}

inline void Hello::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_url_){}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.connection_secret_){}
    , decltype(_impl_.constraints_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.base_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connection_secret_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.connection_secret_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hello::~Hello() {
  // @@protoc_insertion_point(destructor:loon.Hello)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hello::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.base_url_.Destroy();
  _impl_.client_id_.Destroy();
  _impl_.connection_secret_.Destroy();
  if (this != internal_default_instance()) delete _impl_.constraints_;
}

void Hello::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hello::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.Hello)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_url_.ClearToEmpty();
  _impl_.client_id_.ClearToEmpty();
  _impl_.connection_secret_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.constraints_ != nullptr) {
    delete _impl_.constraints_;
  }
  _impl_.constraints_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Hello::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string base_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_base_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.Hello.base_url"));
        } else
          goto handle_unusual;
        continue;
      // string client_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.Hello.client_id"));
        } else
          goto handle_unusual;
        continue;
      // bytes connection_secret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_connection_secret();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.Constraints constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_constraints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hello::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.Hello)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string base_url = 1;
  if (!this->_internal_base_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_base_url().data(), static_cast<int>(this->_internal_base_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.Hello.base_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_base_url(), target);
  }

  // string client_id = 2;
  if (!this->_internal_client_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_id().data(), static_cast<int>(this->_internal_client_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.Hello.client_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_id(), target);
  }

  // bytes connection_secret = 3;
  if (!this->_internal_connection_secret().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_connection_secret(), target);
  }

  // .loon.Constraints constraints = 4;
  if (this->_internal_has_constraints()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::constraints(this),
        _Internal::constraints(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.Hello)
  return target;
}

size_t Hello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.Hello)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string base_url = 1;
  if (!this->_internal_base_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_base_url());
  }

  // string client_id = 2;
  if (!this->_internal_client_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());
  }

  // bytes connection_secret = 3;
  if (!this->_internal_connection_secret().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_connection_secret());
  }

  // .loon.Constraints constraints = 4;
  if (this->_internal_has_constraints()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.constraints_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Hello::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Hello::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Hello::GetClassData() const { return &_class_data_; }


void Hello::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Hello*>(&to_msg);
  auto& from = static_cast<const Hello&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.Hello)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_base_url().empty()) {
    _this->_internal_set_base_url(from._internal_base_url());
  }
  if (!from._internal_client_id().empty()) {
    _this->_internal_set_client_id(from._internal_client_id());
  }
  if (!from._internal_connection_secret().empty()) {
    _this->_internal_set_connection_secret(from._internal_connection_secret());
  }
  if (from._internal_has_constraints()) {
    _this->_internal_mutable_constraints()->::loon::Constraints::MergeFrom(
        from._internal_constraints());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Hello::CopyFrom(const Hello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.Hello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hello::IsInitialized() const {
  return true;
}

void Hello::InternalSwap(Hello* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_url_, lhs_arena,
      &other->_impl_.base_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_id_, lhs_arena,
      &other->_impl_.client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.connection_secret_, lhs_arena,
      &other->_impl_.connection_secret_, rhs_arena
  );
  swap(_impl_.constraints_, other->_impl_.constraints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Hello::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[1]);
}

// ===================================================================

class Request::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const Request* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Request::_Internal::timestamp(const Request* msg) {
  return *msg->_impl_.timestamp_;
}
void Request::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:loon.Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:loon.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  _impl_.id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.Request.path"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // .google.protobuf.Timestamp timestamp = 2;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // string path = 3;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.Request.path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 3;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // .google.protobuf.Timestamp timestamp = 2;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Request, _impl_.id_)
      + sizeof(Request::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(Request, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[2]);
}

// ===================================================================

class EmptyResponse::_Internal {
 public:
};

EmptyResponse::EmptyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.EmptyResponse)
}
EmptyResponse::EmptyResponse(const EmptyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmptyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.request_id_ = from._impl_.request_id_;
  // @@protoc_insertion_point(copy_constructor:loon.EmptyResponse)
}

inline void EmptyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EmptyResponse::~EmptyResponse() {
  // @@protoc_insertion_point(destructor:loon.EmptyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmptyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EmptyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmptyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.EmptyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.request_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmptyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmptyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.EmptyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.EmptyResponse)
  return target;
}

size_t EmptyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.EmptyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmptyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmptyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmptyResponse::GetClassData() const { return &_class_data_; }


void EmptyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmptyResponse*>(&to_msg);
  auto& from = static_cast<const EmptyResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.EmptyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmptyResponse::CopyFrom(const EmptyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.EmptyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmptyResponse::IsInitialized() const {
  return true;
}

void EmptyResponse::InternalSwap(EmptyResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_id_, other->_impl_.request_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmptyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[3]);
}

// ===================================================================

class ContentHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentHeader>()._impl_._has_bits_);
  static void set_has_max_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContentHeader::ContentHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.ContentHeader)
}
ContentHeader::ContentHeader(const ContentHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContentHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_type_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.content_size_){}
    , decltype(_impl_.max_cache_duration_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.content_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content_type().empty()) {
    _this->_impl_.content_type_.Set(from._internal_content_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_cache_duration_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.max_cache_duration_));
  // @@protoc_insertion_point(copy_constructor:loon.ContentHeader)
}

inline void ContentHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_type_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.request_id_){uint64_t{0u}}
    , decltype(_impl_.content_size_){uint64_t{0u}}
    , decltype(_impl_.max_cache_duration_){0u}
  };
  _impl_.content_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentHeader::~ContentHeader() {
  // @@protoc_insertion_point(destructor:loon.ContentHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_type_.Destroy();
  _impl_.filename_.Destroy();
}

void ContentHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContentHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.ContentHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.content_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.content_size_) -
      reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.content_size_));
  _impl_.max_cache_duration_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContentHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string content_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_content_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.ContentHeader.content_type"));
        } else
          goto handle_unusual;
        continue;
      // uint64 content_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.content_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_cache_duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_cache_duration(&has_bits);
          _impl_.max_cache_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.ContentHeader.filename"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.ContentHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // string content_type = 2;
  if (!this->_internal_content_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content_type().data(), static_cast<int>(this->_internal_content_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.ContentHeader.content_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_content_type(), target);
  }

  // uint64 content_size = 3;
  if (this->_internal_content_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_content_size(), target);
  }

  // optional uint32 max_cache_duration = 4;
  if (_internal_has_max_cache_duration()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_max_cache_duration(), target);
  }

  // optional string filename = 5;
  if (_internal_has_filename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.ContentHeader.filename");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.ContentHeader)
  return target;
}

size_t ContentHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.ContentHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string content_type = 2;
  if (!this->_internal_content_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content_type());
  }

  // optional string filename = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  // uint64 content_size = 3;
  if (this->_internal_content_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_content_size());
  }

  // optional uint32 max_cache_duration = 4;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_cache_duration());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContentHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContentHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContentHeader::GetClassData() const { return &_class_data_; }


void ContentHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContentHeader*>(&to_msg);
  auto& from = static_cast<const ContentHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.ContentHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_content_type().empty()) {
    _this->_internal_set_content_type(from._internal_content_type());
  }
  if (from._internal_has_filename()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_content_size() != 0) {
    _this->_internal_set_content_size(from._internal_content_size());
  }
  if (from._internal_has_max_cache_duration()) {
    _this->_internal_set_max_cache_duration(from._internal_max_cache_duration());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContentHeader::CopyFrom(const ContentHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.ContentHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentHeader::IsInitialized() const {
  return true;
}

void ContentHeader::InternalSwap(ContentHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_type_, lhs_arena,
      &other->_impl_.content_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContentHeader, _impl_.max_cache_duration_)
      + sizeof(ContentHeader::_impl_.max_cache_duration_)
      - PROTOBUF_FIELD_OFFSET(ContentHeader, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContentHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[4]);
}

// ===================================================================

class ContentChunk::_Internal {
 public:
};

ContentChunk::ContentChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.ContentChunk)
}
ContentChunk::ContentChunk(const ContentChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContentChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.sequence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sequence_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.sequence_));
  // @@protoc_insertion_point(copy_constructor:loon.ContentChunk)
}

inline void ContentChunk::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.request_id_){uint64_t{0u}}
    , decltype(_impl_.sequence_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentChunk::~ContentChunk() {
  // @@protoc_insertion_point(destructor:loon.ContentChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void ContentChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContentChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.ContentChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sequence_) -
      reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.sequence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContentChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 sequence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.ContentChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // uint64 sequence = 2;
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sequence(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.ContentChunk)
  return target;
}

size_t ContentChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.ContentChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  // uint64 sequence = 2;
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContentChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContentChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContentChunk::GetClassData() const { return &_class_data_; }


void ContentChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContentChunk*>(&to_msg);
  auto& from = static_cast<const ContentChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.ContentChunk)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContentChunk::CopyFrom(const ContentChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.ContentChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentChunk::IsInitialized() const {
  return true;
}

void ContentChunk::InternalSwap(ContentChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContentChunk, _impl_.sequence_)
      + sizeof(ContentChunk::_impl_.sequence_)
      - PROTOBUF_FIELD_OFFSET(ContentChunk, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContentChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[5]);
}

// ===================================================================

class Success::_Internal {
 public:
};

Success::Success(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.Success)
}
Success::Success(const Success& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Success* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.request_id_ = from._impl_.request_id_;
  // @@protoc_insertion_point(copy_constructor:loon.Success)
}

inline void Success::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Success::~Success() {
  // @@protoc_insertion_point(destructor:loon.Success)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Success::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Success::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Success::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.Success)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.request_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Success::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Success::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.Success)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.Success)
  return target;
}

size_t Success::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.Success)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Success::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Success::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Success::GetClassData() const { return &_class_data_; }


void Success::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Success*>(&to_msg);
  auto& from = static_cast<const Success&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.Success)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Success::CopyFrom(const Success& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.Success)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Success::IsInitialized() const {
  return true;
}

void Success::InternalSwap(Success* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_id_, other->_impl_.request_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Success::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[6]);
}

// ===================================================================

class RequestClosed::_Internal {
 public:
};

RequestClosed::RequestClosed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.RequestClosed)
}
RequestClosed::RequestClosed(const RequestClosed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestClosed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.request_id_ = from._impl_.request_id_;
  // @@protoc_insertion_point(copy_constructor:loon.RequestClosed)
}

inline void RequestClosed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.request_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestClosed::~RequestClosed() {
  // @@protoc_insertion_point(destructor:loon.RequestClosed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestClosed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void RequestClosed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestClosed::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.RequestClosed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.request_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestClosed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.RequestClosed.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestClosed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.RequestClosed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.RequestClosed.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.RequestClosed)
  return target;
}

size_t RequestClosed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.RequestClosed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestClosed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestClosed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestClosed::GetClassData() const { return &_class_data_; }


void RequestClosed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestClosed*>(&to_msg);
  auto& from = static_cast<const RequestClosed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.RequestClosed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestClosed::CopyFrom(const RequestClosed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.RequestClosed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestClosed::IsInitialized() const {
  return true;
}

void RequestClosed::InternalSwap(RequestClosed* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.request_id_, other->_impl_.request_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestClosed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[7]);
}

// ===================================================================

class CloseResponse::_Internal {
 public:
};

CloseResponse::CloseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.CloseResponse)
}
CloseResponse::CloseResponse(const CloseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CloseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.request_id_ = from._impl_.request_id_;
  // @@protoc_insertion_point(copy_constructor:loon.CloseResponse)
}

inline void CloseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.request_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CloseResponse::~CloseResponse() {
  // @@protoc_insertion_point(destructor:loon.CloseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CloseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CloseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CloseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.CloseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.request_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CloseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.CloseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.CloseResponse)
  return target;
}

size_t CloseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.CloseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 request_id = 1;
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CloseResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseResponse::GetClassData() const { return &_class_data_; }


void CloseResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CloseResponse*>(&to_msg);
  auto& from = static_cast<const CloseResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.CloseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CloseResponse::CopyFrom(const CloseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.CloseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseResponse::IsInitialized() const {
  return true;
}

void CloseResponse::InternalSwap(CloseResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_id_, other->_impl_.request_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CloseResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[8]);
}

// ===================================================================

class Close::_Internal {
 public:
};

Close::Close(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.Close)
}
Close::Close(const Close& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Close* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.reason_ = from._impl_.reason_;
  // @@protoc_insertion_point(copy_constructor:loon.Close)
}

inline void Close::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.reason_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Close::~Close() {
  // @@protoc_insertion_point(destructor:loon.Close)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Close::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Close::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Close::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.Close)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.reason_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Close::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .loon.Close.Reason reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_reason(static_cast<::loon::Close_Reason>(val));
        } else
          goto handle_unusual;
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "loon.Close.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Close::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.Close)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .loon.Close.Reason reason = 1;
  if (this->_internal_reason() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reason(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "loon.Close.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.Close)
  return target;
}

size_t Close::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.Close)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // .loon.Close.Reason reason = 1;
  if (this->_internal_reason() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Close::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Close::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Close::GetClassData() const { return &_class_data_; }


void Close::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Close*>(&to_msg);
  auto& from = static_cast<const Close&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.Close)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_reason() != 0) {
    _this->_internal_set_reason(from._internal_reason());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Close::CopyFrom(const Close& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.Close)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Close::IsInitialized() const {
  return true;
}

void Close::InternalSwap(Close* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.reason_, other->_impl_.reason_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Close::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[9]);
}

// ===================================================================

class ClientMessage::_Internal {
 public:
  static const ::loon::EmptyResponse& empty_response(const ClientMessage* msg);
  static const ::loon::ContentHeader& content_header(const ClientMessage* msg);
  static const ::loon::ContentChunk& content_chunk(const ClientMessage* msg);
  static const ::loon::CloseResponse& close_response(const ClientMessage* msg);
};

const ::loon::EmptyResponse&
ClientMessage::_Internal::empty_response(const ClientMessage* msg) {
  return *msg->_impl_.data_.empty_response_;
}
const ::loon::ContentHeader&
ClientMessage::_Internal::content_header(const ClientMessage* msg) {
  return *msg->_impl_.data_.content_header_;
}
const ::loon::ContentChunk&
ClientMessage::_Internal::content_chunk(const ClientMessage* msg) {
  return *msg->_impl_.data_.content_chunk_;
}
const ::loon::CloseResponse&
ClientMessage::_Internal::close_response(const ClientMessage* msg) {
  return *msg->_impl_.data_.close_response_;
}
void ClientMessage::set_allocated_empty_response(::loon::EmptyResponse* empty_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (empty_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(empty_response);
    if (message_arena != submessage_arena) {
      empty_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, empty_response, submessage_arena);
    }
    set_has_empty_response();
    _impl_.data_.empty_response_ = empty_response;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ClientMessage.empty_response)
}
void ClientMessage::set_allocated_content_header(::loon::ContentHeader* content_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (content_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_header);
    if (message_arena != submessage_arena) {
      content_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_header, submessage_arena);
    }
    set_has_content_header();
    _impl_.data_.content_header_ = content_header;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ClientMessage.content_header)
}
void ClientMessage::set_allocated_content_chunk(::loon::ContentChunk* content_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (content_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_chunk);
    if (message_arena != submessage_arena) {
      content_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_chunk, submessage_arena);
    }
    set_has_content_chunk();
    _impl_.data_.content_chunk_ = content_chunk;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ClientMessage.content_chunk)
}
void ClientMessage::set_allocated_close_response(::loon::CloseResponse* close_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (close_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(close_response);
    if (message_arena != submessage_arena) {
      close_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_response, submessage_arena);
    }
    set_has_close_response();
    _impl_.data_.close_response_ = close_response;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ClientMessage.close_response)
}
ClientMessage::ClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.ClientMessage)
}
ClientMessage::ClientMessage(const ClientMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_data();
  switch (from.data_case()) {
    case kEmptyResponse: {
      _this->_internal_mutable_empty_response()->::loon::EmptyResponse::MergeFrom(
          from._internal_empty_response());
      break;
    }
    case kContentHeader: {
      _this->_internal_mutable_content_header()->::loon::ContentHeader::MergeFrom(
          from._internal_content_header());
      break;
    }
    case kContentChunk: {
      _this->_internal_mutable_content_chunk()->::loon::ContentChunk::MergeFrom(
          from._internal_content_chunk());
      break;
    }
    case kCloseResponse: {
      _this->_internal_mutable_close_response()->::loon::CloseResponse::MergeFrom(
          from._internal_close_response());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:loon.ClientMessage)
}

inline void ClientMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_data();
}

ClientMessage::~ClientMessage() {
  // @@protoc_insertion_point(destructor:loon.ClientMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_data()) {
    clear_data();
  }
}

void ClientMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientMessage::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:loon.ClientMessage)
  switch (data_case()) {
    case kEmptyResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.empty_response_;
      }
      break;
    }
    case kContentHeader: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.content_header_;
      }
      break;
    }
    case kContentChunk: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.content_chunk_;
      }
      break;
    }
    case kCloseResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.close_response_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void ClientMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.ClientMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .loon.EmptyResponse empty_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_empty_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.ContentHeader content_header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_content_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.ContentChunk content_chunk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_content_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.CloseResponse close_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_close_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.ClientMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .loon.EmptyResponse empty_response = 1;
  if (_internal_has_empty_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::empty_response(this),
        _Internal::empty_response(this).GetCachedSize(), target, stream);
  }

  // .loon.ContentHeader content_header = 2;
  if (_internal_has_content_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::content_header(this),
        _Internal::content_header(this).GetCachedSize(), target, stream);
  }

  // .loon.ContentChunk content_chunk = 3;
  if (_internal_has_content_chunk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::content_chunk(this),
        _Internal::content_chunk(this).GetCachedSize(), target, stream);
  }

  // .loon.CloseResponse close_response = 4;
  if (_internal_has_close_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::close_response(this),
        _Internal::close_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.ClientMessage)
  return target;
}

size_t ClientMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.ClientMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (data_case()) {
    // .loon.EmptyResponse empty_response = 1;
    case kEmptyResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.empty_response_);
      break;
    }
    // .loon.ContentHeader content_header = 2;
    case kContentHeader: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.content_header_);
      break;
    }
    // .loon.ContentChunk content_chunk = 3;
    case kContentChunk: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.content_chunk_);
      break;
    }
    // .loon.CloseResponse close_response = 4;
    case kCloseResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.close_response_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientMessage::GetClassData() const { return &_class_data_; }


void ClientMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientMessage*>(&to_msg);
  auto& from = static_cast<const ClientMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.ClientMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.data_case()) {
    case kEmptyResponse: {
      _this->_internal_mutable_empty_response()->::loon::EmptyResponse::MergeFrom(
          from._internal_empty_response());
      break;
    }
    case kContentHeader: {
      _this->_internal_mutable_content_header()->::loon::ContentHeader::MergeFrom(
          from._internal_content_header());
      break;
    }
    case kContentChunk: {
      _this->_internal_mutable_content_chunk()->::loon::ContentChunk::MergeFrom(
          from._internal_content_chunk());
      break;
    }
    case kCloseResponse: {
      _this->_internal_mutable_close_response()->::loon::CloseResponse::MergeFrom(
          from._internal_close_response());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientMessage::CopyFrom(const ClientMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.ClientMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMessage::IsInitialized() const {
  return true;
}

void ClientMessage::InternalSwap(ClientMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[10]);
}

// ===================================================================

class ServerMessage::_Internal {
 public:
  static const ::loon::Hello& hello(const ServerMessage* msg);
  static const ::loon::Request& request(const ServerMessage* msg);
  static const ::loon::Success& success(const ServerMessage* msg);
  static const ::loon::RequestClosed& request_closed(const ServerMessage* msg);
  static const ::loon::Close& close(const ServerMessage* msg);
};

const ::loon::Hello&
ServerMessage::_Internal::hello(const ServerMessage* msg) {
  return *msg->_impl_.data_.hello_;
}
const ::loon::Request&
ServerMessage::_Internal::request(const ServerMessage* msg) {
  return *msg->_impl_.data_.request_;
}
const ::loon::Success&
ServerMessage::_Internal::success(const ServerMessage* msg) {
  return *msg->_impl_.data_.success_;
}
const ::loon::RequestClosed&
ServerMessage::_Internal::request_closed(const ServerMessage* msg) {
  return *msg->_impl_.data_.request_closed_;
}
const ::loon::Close&
ServerMessage::_Internal::close(const ServerMessage* msg) {
  return *msg->_impl_.data_.close_;
}
void ServerMessage::set_allocated_hello(::loon::Hello* hello) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (hello) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hello);
    if (message_arena != submessage_arena) {
      hello = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hello, submessage_arena);
    }
    set_has_hello();
    _impl_.data_.hello_ = hello;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ServerMessage.hello)
}
void ServerMessage::set_allocated_request(::loon::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    set_has_request();
    _impl_.data_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ServerMessage.request)
}
void ServerMessage::set_allocated_success(::loon::Success* success) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (success) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(success);
    if (message_arena != submessage_arena) {
      success = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    set_has_success();
    _impl_.data_.success_ = success;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ServerMessage.success)
}
void ServerMessage::set_allocated_request_closed(::loon::RequestClosed* request_closed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (request_closed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_closed);
    if (message_arena != submessage_arena) {
      request_closed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_closed, submessage_arena);
    }
    set_has_request_closed();
    _impl_.data_.request_closed_ = request_closed;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ServerMessage.request_closed)
}
void ServerMessage::set_allocated_close(::loon::Close* close) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (close) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(close);
    if (message_arena != submessage_arena) {
      close = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close, submessage_arena);
    }
    set_has_close();
    _impl_.data_.close_ = close;
  }
  // @@protoc_insertion_point(field_set_allocated:loon.ServerMessage.close)
}
ServerMessage::ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:loon.ServerMessage)
}
ServerMessage::ServerMessage(const ServerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_data();
  switch (from.data_case()) {
    case kHello: {
      _this->_internal_mutable_hello()->::loon::Hello::MergeFrom(
          from._internal_hello());
      break;
    }
    case kRequest: {
      _this->_internal_mutable_request()->::loon::Request::MergeFrom(
          from._internal_request());
      break;
    }
    case kSuccess: {
      _this->_internal_mutable_success()->::loon::Success::MergeFrom(
          from._internal_success());
      break;
    }
    case kRequestClosed: {
      _this->_internal_mutable_request_closed()->::loon::RequestClosed::MergeFrom(
          from._internal_request_closed());
      break;
    }
    case kClose: {
      _this->_internal_mutable_close()->::loon::Close::MergeFrom(
          from._internal_close());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:loon.ServerMessage)
}

inline void ServerMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_data();
}

ServerMessage::~ServerMessage() {
  // @@protoc_insertion_point(destructor:loon.ServerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_data()) {
    clear_data();
  }
}

void ServerMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerMessage::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:loon.ServerMessage)
  switch (data_case()) {
    case kHello: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.hello_;
      }
      break;
    }
    case kRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.request_;
      }
      break;
    }
    case kSuccess: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.success_;
      }
      break;
    }
    case kRequestClosed: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.request_closed_;
      }
      break;
    }
    case kClose: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.close_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void ServerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:loon.ServerMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .loon.Hello hello = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_hello(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.Request request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.Success success = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_success(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.RequestClosed request_closed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_closed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .loon.Close close = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_close(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loon.ServerMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .loon.Hello hello = 1;
  if (_internal_has_hello()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::hello(this),
        _Internal::hello(this).GetCachedSize(), target, stream);
  }

  // .loon.Request request = 2;
  if (_internal_has_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::request(this),
        _Internal::request(this).GetCachedSize(), target, stream);
  }

  // .loon.Success success = 3;
  if (_internal_has_success()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::success(this),
        _Internal::success(this).GetCachedSize(), target, stream);
  }

  // .loon.RequestClosed request_closed = 4;
  if (_internal_has_request_closed()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::request_closed(this),
        _Internal::request_closed(this).GetCachedSize(), target, stream);
  }

  // .loon.Close close = 5;
  if (_internal_has_close()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::close(this),
        _Internal::close(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loon.ServerMessage)
  return target;
}

size_t ServerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loon.ServerMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (data_case()) {
    // .loon.Hello hello = 1;
    case kHello: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.hello_);
      break;
    }
    // .loon.Request request = 2;
    case kRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.request_);
      break;
    }
    // .loon.Success success = 3;
    case kSuccess: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.success_);
      break;
    }
    // .loon.RequestClosed request_closed = 4;
    case kRequestClosed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.request_closed_);
      break;
    }
    // .loon.Close close = 5;
    case kClose: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.close_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerMessage::GetClassData() const { return &_class_data_; }


void ServerMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerMessage*>(&to_msg);
  auto& from = static_cast<const ServerMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:loon.ServerMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.data_case()) {
    case kHello: {
      _this->_internal_mutable_hello()->::loon::Hello::MergeFrom(
          from._internal_hello());
      break;
    }
    case kRequest: {
      _this->_internal_mutable_request()->::loon::Request::MergeFrom(
          from._internal_request());
      break;
    }
    case kSuccess: {
      _this->_internal_mutable_success()->::loon::Success::MergeFrom(
          from._internal_success());
      break;
    }
    case kRequestClosed: {
      _this->_internal_mutable_request_closed()->::loon::RequestClosed::MergeFrom(
          from._internal_request_closed());
      break;
    }
    case kClose: {
      _this->_internal_mutable_close()->::loon::Close::MergeFrom(
          from._internal_close());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerMessage::CopyFrom(const ServerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loon.ServerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerMessage::IsInitialized() const {
  return true;
}

void ServerMessage::InternalSwap(ServerMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_loon_2fmessages_2eproto_getter, &descriptor_table_loon_2fmessages_2eproto_once,
      file_level_metadata_loon_2fmessages_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace loon
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::loon::Constraints*
Arena::CreateMaybeMessage< ::loon::Constraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::Constraints >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::Hello*
Arena::CreateMaybeMessage< ::loon::Hello >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::Hello >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::Request*
Arena::CreateMaybeMessage< ::loon::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::EmptyResponse*
Arena::CreateMaybeMessage< ::loon::EmptyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::EmptyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::ContentHeader*
Arena::CreateMaybeMessage< ::loon::ContentHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::ContentHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::ContentChunk*
Arena::CreateMaybeMessage< ::loon::ContentChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::ContentChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::Success*
Arena::CreateMaybeMessage< ::loon::Success >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::Success >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::RequestClosed*
Arena::CreateMaybeMessage< ::loon::RequestClosed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::RequestClosed >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::CloseResponse*
Arena::CreateMaybeMessage< ::loon::CloseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::CloseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::Close*
Arena::CreateMaybeMessage< ::loon::Close >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::Close >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::ClientMessage*
Arena::CreateMaybeMessage< ::loon::ClientMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::ClientMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::loon::ServerMessage*
Arena::CreateMaybeMessage< ::loon::ServerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loon::ServerMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
