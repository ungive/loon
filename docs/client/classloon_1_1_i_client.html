<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>loon: loon::IClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">loon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceloon.html">loon</a></li><li class="navelem"><a class="el" href="classloon_1_1_i_client.html">IClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classloon_1_1_i_client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">loon::IClient Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The interface for a loon client.  
 <a href="classloon_1_1_i_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="client_8h_source.html">client.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for loon::IClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classloon_1_1_i_client.png" usemap="#loon::IClient_map" alt=""/>
  <map id="loon::IClient_map" name="loon::IClient_map">
<area href="classloon_1_1_client.html" title="The loon client." alt="loon::Client" shape="rect" coords="0,56,118,80"/>
<area href="classloon_1_1_i_shared_client.html" title="A client that uses a shared connection by wrapping a real client." alt="loon::ISharedClient" shape="rect" coords="128,56,246,80"/>
<area href="classloon_1_1_shared_client.html" alt="loon::SharedClient" shape="rect" coords="128,112,246,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36ebc791e4c569ea756d2c758b904427" id="r_a36ebc791e4c569ea756d2c758b904427"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a36ebc791e4c569ea756d2c758b904427">~IClient</a> ()</td></tr>
<tr class="separator:a36ebc791e4c569ea756d2c758b904427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e4dcbc229a52f81c93d68b1eff41d2" id="r_a65e4dcbc229a52f81c93d68b1eff41d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2">start</a> ()=0</td></tr>
<tr class="memdesc:a65e4dcbc229a52f81c93d68b1eff41d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the server and maintains a connection.  <br /></td></tr>
<tr class="separator:a65e4dcbc229a52f81c93d68b1eff41d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45970b702e6fae206a0ae6256323b414" id="r_a45970b702e6fae206a0ae6256323b414"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a45970b702e6fae206a0ae6256323b414">stop</a> ()=0</td></tr>
<tr class="memdesc:a45970b702e6fae206a0ae6256323b414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the client and disconnects in the background.  <br /></td></tr>
<tr class="separator:a45970b702e6fae206a0ae6256323b414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9c34f3e65408e39dfab3f25836b5ee" id="r_a7d9c34f3e65408e39dfab3f25836b5ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a7d9c34f3e65408e39dfab3f25836b5ee">terminate</a> ()=0</td></tr>
<tr class="memdesc:a7d9c34f3e65408e39dfab3f25836b5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts any connection and waits until all threads terminated.  <br /></td></tr>
<tr class="separator:a7d9c34f3e65408e39dfab3f25836b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4698e2d6c1883a47f4442a5ce957543c" id="r_a4698e2d6c1883a47f4442a5ce957543c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a4698e2d6c1883a47f4442a5ce957543c">started</a> ()=0</td></tr>
<tr class="memdesc:a4698e2d6c1883a47f4442a5ce957543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the client is started.  <br /></td></tr>
<tr class="separator:a4698e2d6c1883a47f4442a5ce957543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a40d5d4b165f47b63f3943e4129ce1" id="r_a89a40d5d4b165f47b63f3943e4129ce1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a89a40d5d4b165f47b63f3943e4129ce1">idle</a> ()=0</td></tr>
<tr class="memdesc:a89a40d5d4b165f47b63f3943e4129ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the client into idle.  <br /></td></tr>
<tr class="separator:a89a40d5d4b165f47b63f3943e4129ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f466d3bd5d6893c6d9a0a950cb13df9" id="r_a8f466d3bd5d6893c6d9a0a950cb13df9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a8f466d3bd5d6893c6d9a0a950cb13df9">wait_until_ready</a> (std::chrono::milliseconds timeout)=0</td></tr>
<tr class="memdesc:a8f466d3bd5d6893c6d9a0a950cb13df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the client is ready.  <br /></td></tr>
<tr class="separator:a8f466d3bd5d6893c6d9a0a950cb13df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea69decea2b0f141e03038cc83bb36b" id="r_adea69decea2b0f141e03038cc83bb36b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#adea69decea2b0f141e03038cc83bb36b">wait_until_ready</a> ()=0</td></tr>
<tr class="memdesc:adea69decea2b0f141e03038cc83bb36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the client is ready.  <br /></td></tr>
<tr class="separator:adea69decea2b0f141e03038cc83bb36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a3a504182963ea5ee32e46ff643881" id="r_a11a3a504182963ea5ee32e46ff643881"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a11a3a504182963ea5ee32e46ff643881">on_ready</a> (std::function&lt; void()&gt; callback)=0</td></tr>
<tr class="memdesc:a11a3a504182963ea5ee32e46ff643881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback for when the client is connected and ready.  <br /></td></tr>
<tr class="separator:a11a3a504182963ea5ee32e46ff643881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b60a9734beb3c6ee127c342b57ba6df" id="r_a7b60a9734beb3c6ee127c342b57ba6df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a7b60a9734beb3c6ee127c342b57ba6df">on_disconnect</a> (std::function&lt; void()&gt; callback)=0</td></tr>
<tr class="memdesc:a7b60a9734beb3c6ee127c342b57ba6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback for when the client disconnected.  <br /></td></tr>
<tr class="separator:a7b60a9734beb3c6ee127c342b57ba6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfec7a4309eb3ca28e62bd868ebfa5f" id="r_afdfec7a4309eb3ca28e62bd868ebfa5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#afdfec7a4309eb3ca28e62bd868ebfa5f">on_failed</a> (std::function&lt; void()&gt; callback)=0</td></tr>
<tr class="memdesc:afdfec7a4309eb3ca28e62bd868ebfa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback for when the client has unrecoverably failed.  <br /></td></tr>
<tr class="separator:afdfec7a4309eb3ca28e62bd868ebfa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd77b38a5c64aa6559a195d00fd9b47" id="r_a3dd77b38a5c64aa6559a195d00fd9b47"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a3dd77b38a5c64aa6559a195d00fd9b47">register_content</a> (std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_source.html">ContentSource</a> &gt; source, <a class="el" href="structloon_1_1_content_info.html">ContentInfo</a> const &amp;info, std::chrono::milliseconds timeout)=0</td></tr>
<tr class="memdesc:a3dd77b38a5c64aa6559a195d00fd9b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers content with this client and returns a handle for it.  <br /></td></tr>
<tr class="separator:a3dd77b38a5c64aa6559a195d00fd9b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4deb7936906d2fdc59c974b90aa46e" id="r_abd4deb7936906d2fdc59c974b90aa46e"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#abd4deb7936906d2fdc59c974b90aa46e">register_content</a> (std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_source.html">ContentSource</a> &gt; source, <a class="el" href="structloon_1_1_content_info.html">ContentInfo</a> const &amp;info)=0</td></tr>
<tr class="memdesc:abd4deb7936906d2fdc59c974b90aa46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers content with this client and returns a handle for it.  <br /></td></tr>
<tr class="separator:abd4deb7936906d2fdc59c974b90aa46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ddfe0d1c11db19153bd0e5ed36d94c" id="r_a10ddfe0d1c11db19153bd0e5ed36d94c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#a10ddfe0d1c11db19153bd0e5ed36d94c">unregister_content</a> (std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; handle)=0</td></tr>
<tr class="memdesc:a10ddfe0d1c11db19153bd0e5ed36d94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters registered content from this client.  <br /></td></tr>
<tr class="separator:a10ddfe0d1c11db19153bd0e5ed36d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0489c818d25abd3798559005e34e513" id="r_ab0489c818d25abd3798559005e34e513"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#ab0489c818d25abd3798559005e34e513">content</a> ()=0</td></tr>
<tr class="memdesc:ab0489c818d25abd3798559005e34e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all handles of content that is currently registered.  <br /></td></tr>
<tr class="separator:ab0489c818d25abd3798559005e34e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5106084d653c41e23aea7408199d2f1" id="r_ab5106084d653c41e23aea7408199d2f1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloon_1_1_i_client.html#ab5106084d653c41e23aea7408199d2f1">is_registered</a> (std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; handle)=0</td></tr>
<tr class="memdesc:ab5106084d653c41e23aea7408199d2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the content handle is still registered and served.  <br /></td></tr>
<tr class="separator:ab5106084d653c41e23aea7408199d2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The interface for a loon client. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36ebc791e4c569ea756d2c758b904427" name="a36ebc791e4c569ea756d2c758b904427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ebc791e4c569ea756d2c758b904427">&#9670;&#160;</a></span>~IClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual loon::IClient::~IClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0489c818d25abd3798559005e34e513" name="ab0489c818d25abd3798559005e34e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0489c818d25abd3798559005e34e513">&#9670;&#160;</a></span>content()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; &gt; loon::IClient::content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all handles of content that is currently registered. </p>
<p>Represents a snapshot of registered content. Might get invalidated if any of the handles are unregistered or if the client disconnects, fails or is stopped in the meantime.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of content handles. </dd></dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#ad9bf7d60a700ad35d94e1837ee1e10f8">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a99c774eba4c908eee76db33edbfacaa5">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a89a40d5d4b165f47b63f3943e4129ce1" name="a89a40d5d4b165f47b63f3943e4129ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a40d5d4b165f47b63f3943e4129ce1">&#9670;&#160;</a></span>idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the client into idle. </p>
<p>Enable idling when the client is not in active use right now and registered content is not required to be available online, but the client might be put to use again in the very near future, where disconnecting immediately might be considered inefficient.</p>
<p>Once idling, the client disconnects from the server after the timeout that was configured with <a class="el" href="structloon_1_1_client_options.html#a3b0e61069cf2e50eebf7fda279a0e365" title="Automatically disconnect after the given idle duration.">ClientOptions::disconnect_after_idle</a>. To put it out of idle again, either call <a class="el" href="classloon_1_1_i_client.html#a3dd77b38a5c64aa6559a195d00fd9b47" title="Registers content with this client and returns a handle for it.">register_content()</a> or call <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a> again, if content is already registered. Calling <a class="el" href="classloon_1_1_i_client.html#a45970b702e6fae206a0ae6256323b414" title="Stops the client and disconnects in the background.">stop()</a> also puts the client out of idling.</p>
<p>If no timeout period was configured, this method has no effect. If the client is currently stopped, this method has no effect. If the client is disconnected and in the process of reconnecting, the client will be put into idle at the point of reconnecting, if automatic idling has been enabled in the client options.</p>
<p>Note that the client might be put into idle automatically, depending on the value of <a class="el" href="structloon_1_1_client_options.html#adeec907a80042abd08712fb113538af8" title="Enables automatic idling whenever no content is registered.">ClientOptions::automatic_idling</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structloon_1_1_client_options.html#a3b0e61069cf2e50eebf7fda279a0e365" title="Automatically disconnect after the given idle duration.">ClientOptions::disconnect_after_idle</a> </dd>
<dd>
<a class="el" href="structloon_1_1_client_options.html#adeec907a80042abd08712fb113538af8" title="Enables automatic idling whenever no content is registered.">ClientOptions::automatic_idling</a> </dd></dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a413a3152dffe8d3c9b04ee74266f96c7">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a7fb254b39226231a4f10a83263bcdcb3">loon::SharedClient</a>.</p>

</div>
</div>
<a id="ab5106084d653c41e23aea7408199d2f1" name="ab5106084d653c41e23aea7408199d2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5106084d653c41e23aea7408199d2f1">&#9670;&#160;</a></span>is_registered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool loon::IClient::is_registered </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the content handle is still registered and served. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The content handle to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the content handle is still registered with this client.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classloon_1_1_malformed_content_exception.html" title="The content is malformed.">MalformedContentException</a></td><td>if the content is null or has the wrong type. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a82d2074bc531c6812486ef855d67edd1">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#abded10c3b5bf81d693d708cd057affaa">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a7b60a9734beb3c6ee127c342b57ba6df" name="a7b60a9734beb3c6ee127c342b57ba6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b60a9734beb3c6ee127c342b57ba6df">&#9670;&#160;</a></span>on_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::on_disconnect </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a callback for when the client disconnected. </p>
<p>This method is only called after <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a> has been called and only after the client was connected and the <a class="el" href="classloon_1_1_i_client.html#a11a3a504182963ea5ee32e46ff643881" title="Sets a callback for when the client is connected and ready.">on_ready()</a> callback was called.</p>
<p>This callback is guaranteed to be called, even when the client fails.</p>
<p>It is recommended to call this method before <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a>, to reliably detect client ready state. Do not call any client methods within the callback, as client locks are held when it is called, which would cause a deadlock. </p>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#aef0cc9d07c809caba7b13bfe1eb084ce">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#adb9b0cc3c0ddf734c99153bf1ef16f06">loon::SharedClient</a>.</p>

</div>
</div>
<a id="afdfec7a4309eb3ca28e62bd868ebfa5f" name="afdfec7a4309eb3ca28e62bd868ebfa5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfec7a4309eb3ca28e62bd868ebfa5f">&#9670;&#160;</a></span>on_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::on_failed </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a callback for when the client has unrecoverably failed. </p>
<p>This callback is only called when an abnormal event occurs, like an unacceptable server configuration that does not allow the client to continue operation. The callback is not called when the client is stopped with <a class="el" href="classloon_1_1_i_client.html#a45970b702e6fae206a0ae6256323b414" title="Stops the client and disconnects in the background.">stop()</a> or when the <a class="el" href="classloon_1_1_client.html" title="The loon client.">Client</a> instance is destructed in the destructor. The client is stopped when this method is called.</p>
<p>It is recommended to call this method before <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a>, to reliably detect client failures. Do not call any client methods within the callback, as client locks are held when it is called, which would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to call when the client failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a2bd51caf0885655259f3084073dab8a1">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a94f24b8bfca467d96706d93893437153">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a11a3a504182963ea5ee32e46ff643881" name="a11a3a504182963ea5ee32e46ff643881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a3a504182963ea5ee32e46ff643881">&#9670;&#160;</a></span>on_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::on_ready </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a callback for when the client is connected and ready. </p>
<p>This method is called during or after <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a> has been called and it indicates that the client is ready to serve registered content.</p>
<p>The registered callback is guaranteed to be executed before any call to <a class="el" href="classloon_1_1_i_client.html#adea69decea2b0f141e03038cc83bb36b" title="Wait until the client is ready.">wait_until_ready()</a> returns.</p>
<p>It is recommended to call this method before <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a>, to reliably detect client ready state. Do not call any client methods within the callback, as client locks are held when it is called, which would cause a deadlock. </p>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a710900e71255be92d911d23fa080f963">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a0a24ada025615798f6ec167e5c75b59f">loon::SharedClient</a>.</p>

</div>
</div>
<a id="abd4deb7936906d2fdc59c974b90aa46e" name="abd4deb7936906d2fdc59c974b90aa46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4deb7936906d2fdc59c974b90aa46e">&#9670;&#160;</a></span>register_content() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; loon::IClient::register_content </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_source.html">ContentSource</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structloon_1_1_content_info.html">ContentInfo</a> const &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers content with this client and returns a handle for it. </p>
<p>Uses the connect timeout or a sane default value for the timeout.</p>
<dl class="section see"><dt>See also</dt><dd>IClient::register_content(source, info, timeout) </dd>
<dd>
<a class="el" href="structloon_1_1_websocket_options.html#a6510c2bf1331779dc49ae9826d7ba68a" title="The time after which a connection attempt times out.">WebsocketOptions::connect_timeout</a> </dd></dl>

</div>
</div>
<a id="a3dd77b38a5c64aa6559a195d00fd9b47" name="a3dd77b38a5c64aa6559a195d00fd9b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd77b38a5c64aa6559a195d00fd9b47">&#9670;&#160;</a></span>register_content() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt; loon::IClient::register_content </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_source.html">ContentSource</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structloon_1_1_content_info.html">ContentInfo</a> const &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers content with this client and returns a handle for it. </p>
<p>The content is registered for the lifetime of the websocket connection or until it is unregistered with <a class="el" href="classloon_1_1_i_client.html#a10ddfe0d1c11db19153bd0e5ed36d94c" title="Unregisters registered content from this client.">unregister_content()</a>. It is necessary to re-register the content again after a disconnect.</p>
<p>Calls to any of the methods of the source are synchronized. The source's data() method is only called once per request and while no other requests are being handled that are using a previous return value of it. If the source reads from a file e.g., the data() method can safely seek to the beginning of the file without having to worry about corrupting other ongoing requests.</p>
<p>If the client is idling, the client is put out of idle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source for the content. </td></tr>
    <tr><td class="paramname">info</td><td>Information about how to provide the content. </td></tr>
    <tr><td class="paramname">timeout</td><td>How long to wait until the connection is ready, if it isn't yet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the content. For use with <a class="el" href="classloon_1_1_i_client.html#a10ddfe0d1c11db19153bd0e5ed36d94c" title="Unregisters registered content from this client.">unregister_content()</a> to unregister this content again.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classloon_1_1_timeout_exception.html" title="The operation timed out.">TimeoutException</a></td><td>if an operation timed out. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_client_not_connected_exception.html" title="The client is not connected to the server.">ClientNotConnectedException</a></td><td>if the client is not started, connected or if the client disconnected while waiting for the connection to be ready. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_path_already_registered_exception.html" title="Content is already registered under this path.">PathAlreadyRegisteredException</a></td><td>if content has already been registered under the path that was specified in the info parameter. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_malformed_content_exception.html" title="The content is malformed.">MalformedContentException</a></td><td>if the content has a size of zero bytes. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_unacceptable_content_exception.html" title="The content does not conform with the server&#39;s constraints.">UnacceptableContentException</a></td><td>if the server's constraints do not allow this content. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e4dcbc229a52f81c93d68b1eff41d2" name="a65e4dcbc229a52f81c93d68b1eff41d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e4dcbc229a52f81c93d68b1eff41d2">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects to the server and maintains a connection. </p>
<p>Attempts to reconnect on connection failure or disconnect, until <a class="el" href="classloon_1_1_i_client.html#a45970b702e6fae206a0ae6256323b414" title="Stops the client and disconnects in the background.">stop()</a> is called. Returns immediately and does nothing, if already starting or started. Disables idling, if the client is in idle state. </p>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#ab956e5add223ba7a8ab6df2e4c465134">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a13b6f93180c074ff38a4a96b6d3958fd">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a4698e2d6c1883a47f4442a5ce957543c" name="a4698e2d6c1883a47f4442a5ce957543c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4698e2d6c1883a47f4442a5ce957543c">&#9670;&#160;</a></span>started()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool loon::IClient::started </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the client is started. </p>
<p>Call <a class="el" href="classloon_1_1_i_client.html#adea69decea2b0f141e03038cc83bb36b" title="Wait until the client is ready.">wait_until_ready()</a> to wait until the client is ready for registering content with <a class="el" href="classloon_1_1_i_client.html#a3dd77b38a5c64aa6559a195d00fd9b47" title="Registers content with this client and returns a handle for it.">register_content()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>If the client is started. </dd></dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a9e077f78868cb742202aa520b4add5b5">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a3e838d48c6e1212b34c28756960a31e6">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a45970b702e6fae206a0ae6256323b414" name="a45970b702e6fae206a0ae6256323b414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45970b702e6fae206a0ae6256323b414">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the client and disconnects in the background. </p>
<p>This method has a similar effect as <a class="el" href="classloon_1_1_i_client.html#a7d9c34f3e65408e39dfab3f25836b5ee" title="Aborts any connection and waits until all threads terminated.">terminate()</a> but returns immediately. The <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a> method may still be called again after calling this method. Callbacks may still be called after this method returns. </p>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a4da0243ffb3130d0e7a6f65c0a548906">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#ac9be828a202f724f60d5ed518c3170a2">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a7d9c34f3e65408e39dfab3f25836b5ee" name="a7d9c34f3e65408e39dfab3f25836b5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9c34f3e65408e39dfab3f25836b5ee">&#9670;&#160;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts any connection and waits until all threads terminated. </p>
<p>Terminates the client and closes the connection to the server. Notifies all handles that registered content is not available anymore. Also disables idling, if it has been enabled before. Does nothing, if already disconnected or stopped.</p>
<p>Returns once all connections and threads have been terminated. It is guaranteed that no registered callbacks will be called after this method returns. Callbacks may still be called before this method returns.</p>
<p>The <a class="el" href="classloon_1_1_i_client.html#a65e4dcbc229a52f81c93d68b1eff41d2" title="Connects to the server and maintains a connection.">start()</a> method may still be called again after calling this method. </p>

<p>Implemented in <a class="el" href="classloon_1_1_shared_client.html#a788fc6ae7fc9aad58e809213b8177a91">loon::SharedClient</a>, <a class="el" href="classloon_1_1_client.html#a0140bca410945007e65a555a5b41ab74">loon::Client</a>, and <a class="el" href="classloon_1_1_i_shared_client.html#a58a183dd481e140b5f58ebf93e3821ba">loon::ISharedClient</a>.</p>

</div>
</div>
<a id="a10ddfe0d1c11db19153bd0e5ed36d94c" name="a10ddfe0d1c11db19153bd0e5ed36d94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ddfe0d1c11db19153bd0e5ed36d94c">&#9670;&#160;</a></span>unregister_content()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void loon::IClient::unregister_content </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classloon_1_1_content_handle.html">ContentHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters registered content from this client. </p>
<p>Does nothing if the content is already not registered anymore or the client has disconnected from the server or failed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for which the content should be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classloon_1_1_malformed_content_exception.html" title="The content is malformed.">MalformedContentException</a></td><td>if the content is null or has the wrong type. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a119d5ea6cb48ee9faab2d61e24ee2c66">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#ad09be798114ce482252be5d7849b3e35">loon::SharedClient</a>.</p>

</div>
</div>
<a id="adea69decea2b0f141e03038cc83bb36b" name="adea69decea2b0f141e03038cc83bb36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea69decea2b0f141e03038cc83bb36b">&#9670;&#160;</a></span>wait_until_ready() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool loon::IClient::wait_until_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until the client is ready. </p>
<p>Uses the connect timeout or a sane default value for the timeout.</p>
<dl class="section return"><dt>Returns</dt><dd>if the client was already ready and the method returned immediately.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>IClient::wait_until_ready(timeout) </dd>
<dd>
<a class="el" href="structloon_1_1_websocket_options.html#a6510c2bf1331779dc49ae9826d7ba68a" title="The time after which a connection attempt times out.">WebsocketOptions::connect_timeout</a> </dd></dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#a488515bc2a85422f8728c19ed3626f81">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#aa367166d03230962cdb1663e91a397cb">loon::SharedClient</a>.</p>

</div>
</div>
<a id="a8f466d3bd5d6893c6d9a0a950cb13df9" name="a8f466d3bd5d6893c6d9a0a950cb13df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f466d3bd5d6893c6d9a0a950cb13df9">&#9670;&#160;</a></span>wait_until_ready() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool loon::IClient::wait_until_ready </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until the client is ready. </p>
<p>Times out after the given timeout duration, if the client has not successfully connected within that period. The timeout duration must be greater or equal to zero.</p>
<p>Can be used to check whether the client is ready at a specific moment, by using a timeout duration of zero.</p>
<p>Does not throw any exception if the connection is ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout period.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the client was already ready and the method returned immediately.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classloon_1_1_client_not_started_exception.html" title="The client is not started.">ClientNotStartedException</a></td><td>if the client was not started. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_client_not_connected_exception.html" title="The client is not connected to the server.">ClientNotConnectedException</a></td><td>if the client is not connected or if the client disconnected while waiting for the connection to be ready. </td></tr>
    <tr><td class="paramname"><a class="el" href="classloon_1_1_timeout_exception.html" title="The operation timed out.">TimeoutException</a></td><td>if the operation timed out. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classloon_1_1_client.html#aafa07fa52fdabe5a903eda6304c874eb">loon::Client</a>, and <a class="el" href="classloon_1_1_shared_client.html#a3f668b591e1ddad4e78267f252b0b7ff">loon::SharedClient</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/loon/<a class="el" href="client_8h_source.html">client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
